import JuMP, Gurobi
import JuMP.value as ƒ±
import LinearAlgebra.‚ãÖ as ‚ãÖ
import LinearAlgebra.norm as norm
import Random

# I Run this code with 7+1 Threads

function prev(t, d, T) return (n = t - d; n<1 ? T+n : n) end; # used in h[:U]
function gen_a_D_house(ID, Drng) return (
    ID = ID,
    CND = .5rand(1:7), # thermal conductance of the building wall
    INR = rand(6:20), # thermal inertia of the building
    COP = rand(2:.5:4), # how many Watts cooling power for 1-Watt e-power
    Q_I = rand(3:9, T), # heat generated by indoor human activity, server etc.
    Q_BUS = rand(25:35), # RateA of the cooling water/air pipeline
    OH = rand(24:29), # the hottest indoor degree Celsius
    OŒî = rand(4:9), # the coldest indoor degree Celsius = OH - OŒî
    D = rand(Drng, T), # base demand
    P_BUS = rand(12:33), # unidirectional due to no renewables
    P_EV = [2, rand(3:7)], # MIN and MAX charging power
    P_AC = rand(6:9), # AC's cooling power is limited
    E_EV = rand(10:39),
    U = [rand(1:4, rand(2:5)) for _ = 1:rand(1:4)] # an entry is a cycle vector of an uninterruptible load 
) end; function gen_a_G_house(ID, Drng) return (gen_a_D_house(ID, Drng)..., G = rand(3:17, T)) end;
function solve_compact_formulation()
    x = similar(D, NamedTuple); # store the VariableRefs in NamedTuple's
    model = JuMP.Model(Gurobi.Optimizer); # monolithic
    JuMP.set_attribute(model, "MIPGap", 0);
    JuMP.set_attribute(model, "MIPGapAbs", 0);
    for (j, block) = enumerate(D) # operational detail for each individual block
        if length(block) == 1
            h = block[1]
            bEV, pEV = JuMP.@variable(model, [1:T], Bin), JuMP.@variable(model, [1:T]); JuMP.@constraint(model, sum(pEV) ‚â• h[:E_EV])
            JuMP.@constraint(model, h[:P_EV][begin]bEV ‚â§ pEV); JuMP.@constraint(model, pEV ‚â§ h[:P_EV][end]bEV)
            bU = JuMP.@variable(model, [t = 1:T, i = eachindex(h[:U])], Bin); JuMP.@constraint(model, sum(bU; dims = 1) .‚â• true)
            pU = JuMP.@expression(model, [t=1:T], sum(sum(bU[prev(t,œÜ-1,T), i]P for (œÜ,P) = enumerate(v)) for (i,v) = enumerate(h[:U]))) # Uninterruptible demand
            q = JuMP.@variable(model, [1:T], lower_bound = 0, upper_bound = h[:Q_BUS]) # direct cooling power supply
            pAC = JuMP.@variable(model, [1:T], lower_bound = 0, upper_bound = h[:P_AC]) # we consider only cooling mode in this instance
            o = JuMP.@variable(model, [1:T], lower_bound = h[:OH]-h[:OŒî], upper_bound = h[:OH]) # indoor temperature (state variable)
            JuMP.@constraint(model, [t=1:T], (O[t]-o[t])h[:CND] + h[:Q_I][t] -q[t] -h[:COP]pAC[t] == (o[t<T ? t+1 : 1]-o[t])h[:INR]) # dynamic equation
            pBus = JuMP.@variable(model, [1:T], lower_bound = 0, upper_bound = h[:P_BUS]) # unidirectional for NO-DER household
            JuMP.@constraint(model, pBus ‚â• h[:D] + pEV + pU + pAC);
        else
            bLent, pLent = JuMP.@variable(model, [1:T], Bin), JuMP.@variable(model, [1:T])
            bEV, pEV = JuMP.@variable(model, [1:T, 1:2], Bin), JuMP.@variable(model, [1:T, 1:2])
            for (i, h) = enumerate(block) # EV's part
                JuMP.@constraint(model, h[:P_EV][begin]view(bEV, :, i) ‚â§ view(pEV, :, i))
                JuMP.@constraint(model, view(pEV, :, i) ‚â§ h[:P_EV][end]view(bEV, :, i))
                if i == 1 # the household that has RES
                    JuMP.@constraint(model, (1 .- bLent)h[:P_EV][begin] ‚â§ pLent)
                    JuMP.@constraint(model, pLent ‚â§ (1 .- bLent)h[:P_EV][end])
                    JuMP.@constraint(model, h[:E_EV] ‚â§ sum(view(pEV, :, i)))
                else
                    JuMP.@constraint(model, h[:E_EV] ‚â§ sum(view(pEV, :, i)) + sum(pLent))
                end
                JuMP.@constraint(model, view(bEV, :, i) ‚â§ bLent) # bLent = 0 means lending
            end
            bU = JuMP.@variable(model, [i = 1:2, j = eachindex(block[i][:U]), t = 1:T], Bin) # ‚ö†Ô∏è This construct is a bit involved
            JuMP.@constraint(model, [i = 1:2, j = eachindex(block[i][:U])], sum(bU[i, j, :]) .‚â• true)
            pU = JuMP.@expression(model, [i = 1:2, t = 1:T], sum(sum(bU[i, j, prev(t,œÜ-1,T)]P for (œÜ,P) = enumerate(v)) for (j,v) = enumerate(block[i][:U])))
            q = JuMP.@variable(model, [1:T, i = 1:2], lower_bound = 0, upper_bound = block[i][:Q_BUS])
            pAC = JuMP.@variable(model, [1:T, i = 1:2], lower_bound = 0, upper_bound = block[i][:P_AC])
            o = JuMP.@variable(model, [1:T, i = 1:2], lower_bound = block[i][:OH]-block[i][:OŒî], upper_bound = block[i][:OH])
            JuMP.@constraint(model, [t = 1:T, i = 1:2], 
                (O[t]-o[t, i])block[i][:CND] + block[i][:Q_I][t] -q[t, i] -block[i][:COP]pAC[t, i] == (o[t<T ? t+1 : 1, i]-o[t, i])block[i][:INR]
            ); # dynamic equation
            pBus = JuMP.@variable(model, [1:T, i = 1:2], lower_bound = i>1 ? 0 : -block[i][:P_BUS], upper_bound = block[i][:P_BUS])
            for (i, h) = enumerate(block)
                if i == 1
                    JuMP.@constraint(model, view(pBus, :, i) + h[:G] ‚â• pLent + h[:D] + view(pEV, :, i) + view(pU, i, :) + view(pAC, :, i))
                else
                    JuMP.@constraint(model, view(pBus, :, i)         ‚â•         h[:D] + view(pEV, :, i) + view(pU, i, :) + view(pAC, :, i))
                end
            end
        end
        x[j] = (
            q    = q,   
            o    = o,   
            pBus = pBus,
            bEV  = bEV, 
            pEV  = pEV, 
            pAC  = pAC, 
            bU   = bU
        ); length(block) > 1 && (x[j] = (bLent = bLent, pLent = pLent, x[j]...))
    end
    JuMP.@expression(model, pAgr, sum(haskey(x[j], :bLent) ? vec(sum(x[j][:pBus]; dims = 2)) : x[j][:pBus] for j = eachindex(x)))
    JuMP.@expression(model, qAgr, sum(haskey(x[j], :bLent) ? vec(sum(x[j][:q]; dims = 2)) : x[j][:q] for j = eachindex(x)))
    JuMP.@constraint(model, Œ≤[t = 1:T], P_AGR ‚â• pAgr[t]) # üü° Linking (note that we require positiveness thought not explicit here)
    JuMP.@constraint(model, Œº[t = 1:T], Q_AGR ‚â• qAgr[t]) # üü° Linking
    JuMP.@constraint(model, ŒΩ, E_AGR ‚â• sum(qAgr)) # üü° Linking [ice-storage is limited]
    JuMP.@objective(model, Min, MarketPrice ‚ãÖ pAgr)
    JuMP.optimize!(model); JuMP.assert_is_solved_and_feasible(model; allow_local = false)
    ƒ±.(x[1][:bU]);
    println("compact one-shot solved in $(JuMP.solve_time(model)) seconds")
    return an_UB = JuMP.objective_value(model) + 200
end; function initialize_out(an_UB) # an_UB ‚ö†Ô∏è should be valid
    model = JuMP.Model(Gurobi.Optimizer) # outer in DantzigWolfe decomposition
    JuMP.set_silent(model)
    JuMP.@variable(model, Œ≤[1:T] ‚â• 0) # e_power per t
    JuMP.@variable(model, Œº[1:T] ‚â• 0) # q_power per t
    JuMP.@variable(model, ŒΩ ‚â• 0) # q_energy scalar
    JuMP.@variable(model, Œ∏[1:J]) # This is a concise formulation---the cut is info-intensive
    JuMP.@expression(model, common, -sum(Œ≤)P_AGR -sum(Œº)Q_AGR -(ŒΩ)E_AGR)
    JuMP.@expression(model, out_obj_tbMax, common + sum(Œ∏))
    JuMP.@objective(model, Max, out_obj_tbMax)
    JuMP.@constraint(model, out_obj_tbMax ‚â§ an_UB)
    return model, Œ∏, Œ≤, Œº, ŒΩ
end; function initialize_inn(D)
    inn = Vector{JuMP.Model}(undef, J); # the intrablock MIP subproblems
    for (j, block) = enumerate(D)
        model = JuMP.Model(Gurobi.Optimizer)
        JuMP.set_silent(model)
        JuMP.set_attribute(model, "Threads", 1)
        JuMP.set_attribute(model, "TimeLimit", 3)
        JuMP.set_attribute(model, "MIPGap", 0)
        JuMP.set_attribute(model, "MIPGapAbs", 0)
        if length(block) == 1 # [pBus1; pBus2; pLent; vec(pEV); bLent; vec(bEV); vec(bDW)]
            h = block[1]
            JuMP.@variable(model, bEV[1:T], Bin); JuMP.@variable(model, pEV[1:T]); JuMP.@constraint(model, sum(pEV) ‚â• h[:E_EV])
            JuMP.@constraint(model, h[:P_EV][begin]bEV ‚â§ pEV); JuMP.@constraint(model, pEV ‚â§ h[:P_EV][end]bEV)
            JuMP.@variable(model, bU[t = 1:T, i = eachindex(h[:U])], Bin); JuMP.@constraint(model, sum(bU; dims = 1) .‚â• true)
            JuMP.@expression(model, pU[t=1:T], sum(sum(bU[prev(t,œÜ-1,T), i]P for (œÜ,P) = enumerate(v)) for (i,v) = enumerate(h[:U]))) # Uninterruptible demand
            JuMP.@variable(model, q[1:T], lower_bound = 0, upper_bound = h[:Q_BUS]) # direct cooling power supply
            JuMP.@variable(model, pAC[1:T], lower_bound = 0, upper_bound = h[:P_AC]) # we consider only cooling mode in this instance
            JuMP.@variable(model, o[1:T], lower_bound = h[:OH]-h[:OŒî], upper_bound = h[:OH]) # indoor temperature (state variable)
            JuMP.@constraint(model, [t=1:T], (O[t]-o[t])h[:CND] + h[:Q_I][t] -q[t] -h[:COP]pAC[t] == (o[t<T ? t+1 : 1]-o[t])h[:INR]) # dynamic equation
            JuMP.@variable(model, pBus[1:T], lower_bound = 0, upper_bound = h[:P_BUS]) # unidirectional for NO-DER household
            JuMP.@constraint(model, pBus ‚â• h[:D] + pEV + pU + pAC);
            JuMP.@expression(model, prim_obj, MarketPrice ‚ãÖ pBus) # some penalty terms still needed
        else
            JuMP.@variable(model, bLent[1:T], Bin); JuMP.@variable(model, pLent[1:T])
            JuMP.@variable(model, bEV[1:T, 1:2], Bin); JuMP.@variable(model, pEV[1:T, 1:2])
            for (i, h) = enumerate(block) # EV's part
                JuMP.@constraint(model, h[:P_EV][begin]view(bEV, :, i) ‚â§ view(pEV, :, i))
                JuMP.@constraint(model, view(pEV, :, i) ‚â§ h[:P_EV][end]view(bEV, :, i))
                if i == 1 # the household that has RES
                    JuMP.@constraint(model, (1 .- bLent)h[:P_EV][begin] ‚â§ pLent)
                    JuMP.@constraint(model, pLent ‚â§ (1 .- bLent)h[:P_EV][end])
                    JuMP.@constraint(model, h[:E_EV] ‚â§ sum(view(pEV, :, i)))
                else
                    JuMP.@constraint(model, h[:E_EV] ‚â§ sum(view(pEV, :, i)) + sum(pLent))
                end
                JuMP.@constraint(model, view(bEV, :, i) ‚â§ bLent) # bLent = 0 means lending
            end
            JuMP.@variable(model, bU[i = 1:2, j = eachindex(block[i][:U]), t = 1:T], Bin) # ‚ö†Ô∏è This construct is a bit involved
            JuMP.@constraint(model, [i = 1:2, j = eachindex(block[i][:U])], sum(bU[i, j, :]) .‚â• true)
            JuMP.@expression(model, pU[i = 1:2, t = 1:T], sum(sum(bU[i, j, prev(t,œÜ-1,T)]P for (œÜ,P) = enumerate(v)) for (j,v) = enumerate(block[i][:U])))
            JuMP.@variable(model, q[1:T, i = 1:2], lower_bound = 0, upper_bound = block[i][:Q_BUS])
            JuMP.@variable(model, pAC[1:T, i = 1:2], lower_bound = 0, upper_bound = block[i][:P_AC])
            JuMP.@variable(model, o[1:T, i = 1:2], lower_bound = block[i][:OH]-block[i][:OŒî], upper_bound = block[i][:OH])
            JuMP.@constraint(model, [t = 1:T, i = 1:2], 
                (O[t]-o[t, i])block[i][:CND] + block[i][:Q_I][t] -q[t, i] -block[i][:COP]pAC[t, i] == (o[t<T ? t+1 : 1, i]-o[t, i])block[i][:INR]
            ); # dynamic equation
            JuMP.@variable(model, pBus[1:T, i = 1:2], lower_bound = i>1 ? 0 : -block[i][:P_BUS], upper_bound = block[i][:P_BUS])
            for (i, h) = enumerate(block)
                if i == 1
                    JuMP.@constraint(model, view(pBus, :, i) + h[:G] ‚â• pLent + h[:D] + view(pEV, :, i) + view(pU, i, :) + view(pAC, :, i))
                else
                    JuMP.@constraint(model, view(pBus, :, i)         ‚â•         h[:D] + view(pEV, :, i) + view(pU, i, :) + view(pAC, :, i))
                end
            end
            JuMP.@expression(model, prim_obj, MarketPrice ‚ãÖ sum(pBus; dims = 2)) # some penalty terms still needed
        end; inn[j] = model # save
    end # not include: penalty objective, non-block linking constr
    return inn
end; function reset_mj_obj!(mj, Œí, Œú, Œù)
    pair = haskey(mj, :bLent)
    pBus, q = mj[:pBus], mj[:q]
    term_beta = JuMP.@expression(mj, pair ? sum((pBus[t,1] + pBus[t,2])Œí[t] for t=1:T) : Œí ‚ãÖ pBus)
    term_mu = JuMP.@expression(mj, pair ? sum((q[t,1] + q[t,2])Œú[t] for t=1:T) : Œú ‚ãÖ q)
    term_nu = JuMP.@expression(mj, sum(q)Œù)
    JuMP.@objective(mj, Min, +(mj[:prim_obj], term_beta, term_mu, term_nu))
end; function build_con(j, mj)
    pair = haskey(mj, :bLent)
    pBus, q = ƒ±.(mj[:pBus]), ƒ±.(mj[:q])
    term_beta = JuMP.@expression(mj, pair ? sum((pBus[t,1] + pBus[t,2])Œ≤[t] for t=1:T) : Œ≤ ‚ãÖ pBus)
    term_mu = JuMP.@expression(mj, pair ? sum((q[t,1] + q[t,2])Œº[t] for t=1:T) : Œº ‚ãÖ q)
    term_nu = JuMP.@expression(mj, sum(q)ŒΩ)
    cut_term = JuMP.@expression(mj, +(ƒ±(mj[:prim_obj]), term_beta, term_mu, term_nu))
    local con = JuMP.@build_constraint(Œ∏[j] ‚â§ cut_term)
end; 
function get_full_num_tuple(mj)
    x = (
        q = ƒ±.(mj[:q]),
        o = ƒ±.(mj[:o]),
        pBus = ƒ±.(mj[:pBus]),
        bEV = round.(Bool, ƒ±.(mj[:bEV])),
        pEV = ƒ±.(mj[:pEV]),
        pAC = ƒ±.(mj[:pAC]),
        bU = round.(Bool, ƒ±.(mj[:bU]))
    );  haskey(mj, :bLent) && (x = (
        bLent = round.(Bool, ƒ±.(mj[:bLent])),
        pLent = ƒ±.(mj[:pLent]),
        x...
    )); return x
end; function gen_D()
    D = Vector{Vector{NamedTuple}}(undef, 4)
    D[1] = [gen_a_G_house(1, 1:3), gen_a_D_house(2, 0:5)]
    D[2] = [gen_a_D_house(3, 0:5)]
    D[3] = [gen_a_D_house(4, 0:6)]
    D[4] = [gen_a_D_house(5, 0:5)]
    D
end;

# seed = abs(rand(Int))
Random.seed!(2004686255641684212)
const COT = 1e-9
const T = 24; # global data
const MarketPrice = [2, 1, 1, 1, 1, 1, 3, 5, 6, 7, 8, 9, 9, 8, 8, 9, 10, 11, 9, 6, 5, 3, 2, 2];
const P_AGR = 47;
const Q_AGR = 27;
const E_AGR = 200;
const O = [27.0, 27.2, 27.5, 27.8, 28.5, 30.0, 32.5, 35.0, 37.5, 39.5, 41.0, 42.0, 41.5, 40.5, 39.0, 37.0, 34.5, 32.0, 30.0, 29.0, 28.0, 27.5, 27.2, 27.0]; # global data: outdoor temperature
const D = gen_D(); # generate all the households
const J = length(D);
const an_UB = solve_compact_formulation();
const model, Œ∏, Œ≤, Œº, ŒΩ = initialize_out(an_UB);
const inn = initialize_inn(D); # haskey(inn[1], :bLent) == true
const inbox_lock = Threads.ReentrantLock();
const model_lock = Threads.ReentrantLock();
const B = [Dict{NamedTuple, JuMP.ConstraintRef}() for j = 1:J]; # a vec of Bijections::NamedTuple

# ‚ö†Ô∏è you cannot broadcast multiple 1:J tasks asyncly, since they read&write to the SAME inn[j]

function subproblemÀàs_duty(j, snap, inbox) # the fussy version
    mj = inn[j]
    reset_mj_obj!(mj, snap.Œ≤, snap.Œº, snap.ŒΩ)
    JuMP.optimize!(mj); JuMP.assert_is_solved_and_feasible(mj; allow_local = false)
    con = build_con(j, mj) # on the currently solved status of `mj`
    can_cut_off = function(new_snap)
        Œò, Œí, Œú, Œù = new_snap.Œ∏, new_snap.Œ≤, new_snap.Œº, new_snap.ŒΩ
        pair = haskey(mj, :bLent)
        pBus, q = ƒ±.(mj[:pBus]), ƒ±.(mj[:q])
        term_beta = pair ? sum((pBus[t,1] + pBus[t,2])Œí[t] for t=1:T) : Œí ‚ãÖ pBus
        term_mu = pair ? sum((q[t,1] + q[t,2])Œú[t] for t=1:T) : Œú ‚ãÖ q
        term_nu = sum(q)Œù
        cut_term = +(ƒ±(mj[:prim_obj]), term_beta, term_mu, term_nu)
        local is_cut_off = Œò[j] > cut_term + COT
    end
    lens = function(new_snap)
        j, can_cut_off(new_snap), con
    end
    @lock inbox_lock push!(inbox, lens)
end

function masterÀàs_algorithm(Œît)
    function shot!()
        JuMP.optimize!(model); JuMP.assert_is_solved_and_feasible(model; allow_local = false, dual = true)
        println("‚ñ∂ modelÀàs ObjBound = $(JuMP.objective_bound(model))")
        local snap = (t = timestamp += 1, Œ∏ = ƒ±.(Œ∏), Œ≤ = ƒ±.(Œ≤), Œº = ƒ±.(Œº), ŒΩ = ƒ±(ŒΩ))
    end
    function masterÀàs_loop()
        while true
            if isempty(inbox)
                yield()
                continue
            end
            js2reply, is_global_cut_off = Set{Int}(), false
            while !isempty(inbox)
                lens = @lock inbox_lock pop!(inbox)
                local j, is_cut_off, con = lens(snap)
                is_cut_off && @lock model_lock JuMP.add_constraint(model, con)
                println("t = $(snap.t), j = $j, is_cut_off = $is_cut_off")
                push!(js2reply, j)
                is_global_cut_off |= is_cut_off
            end
            if is_global_cut_off
                @lock model_lock snap = shot!()
                t0 = time()
            elseif time() - t0 > Œît
                println("‚ñ∂‚ñ∂‚ñ∂ Long time no improvements, quit!")
                return
            end
            for j = js2reply Threads.@spawn subproblemÀàs_duty(j, snap, inbox) end
        end
    end
    t0 = time()
    timestamp, inbox = -1, Function[]
    snap = shot!()
    masterÀàs_task = Threads.@spawn masterÀàs_loop()
    for j = 1:J Threads.@spawn subproblemÀàs_duty(j, snap, inbox) end
    wait(masterÀàs_task)
end

masterÀàs_algorithm(2)
