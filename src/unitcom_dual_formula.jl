function f_primal( there is an additional -ip(beta2, Z) in the outer layer!!! )
    JuMP.@variable(ø,  ϖ[t = 1:T, w = 1:W] >= 0.)
    JuMP.@variable(ø,  ζ[t = 1:T, l = 1:L] >= 0.)
    JuMP.@variable(ø,  ρ[t = 1:T, g = 1:G] >= 0.)
    JuMP.@variable(ø,  p[t = 1:T, g = 1:G])
    JuMP.@variable(ø, p²[t = 1:T, g = 1:G])
    JuMP.@variable(ø,  e[t = 1:T, g = 1:G] >= 0.)
    JuMP.@constraint(ø, ℵW[t = 1:T, w = 1:W], Wℷ["M"][w] * Y[t, w] >= ϖ[t, w])
    JuMP.@constraint(ø, ℵL[t = 1:T, l = 1:L], Lℷ["M"][l] * Z[t, l] >= ζ[t, l])
    JuMP.@constraint(ø, [t = 1:T, g = 1:G], [p²[t, g] + 1, p²[t, g] - 1, 2 * p[t, g]] in JuMP.SecondOrderCone())
    JuMP.@constraint(ø, ℵe[t = 1:T, g = 1:G], e[t, g] >= Gℷ["C2"][g] * p²[t, g] + Gℷ["C1"][g] * p[t, g] + Gℷ["C0"][g] - (1 - x[t, g]) * Gℷ["M"][g])
    JuMP.@constraint(ø, ℵdl1[g = 1:G], p[1, g] - Gℷ["ZP"][g]       >= -Gℷ["RD"][g] * x[1, g] - Gℷ["SD"][g] * v[1, g])
    JuMP.@constraint(ø, ℵdl[t = 2:T, g = 1:G], p[t, g] - p[t-1, g] >= -Gℷ["RD"][g] * x[t, g] - Gℷ["SD"][g] * v[t, g])
    JuMP.@constraint(ø, ℵdr1[g = 1:G], Gℷ["RU"][g] * Gℷ["ZS"][g] + Gℷ["SU"][g] * u[1, g]       >= p[1, g] - Gℷ["ZP"][g])
    JuMP.@constraint(ø, ℵdr[t = 2:T, g = 1:G], Gℷ["RU"][g] * x[t-1, g] + Gℷ["SU"][g] * u[t, g] >= p[t, g] - p[t-1, g])
    JuMP.@constraint(ø, ℵPI[t = 1:T, g = 1:G], p[t, g] >= Gℷ["PI"][g] * x[t, g])
    JuMP.@constraint(ø, ℵPS[t = 1:T, g = 1:G], Gℷ["PS"][g] * x[t, g] >= p[t, g] + ρ[t, g])
    JuMP.@constraint(ø, ℵbl[t = 1:T, b = 1:B],
        sum(F[b, Gℷ["n"][g]] * p[t, g] for g in 1:G) + sum(F[b, Wℷ["n"][w]] * (Wℷ["M"][w] * Y[t, w] - ϖ[t, w]) for w in 1:W) - sum(F[b, Lℷ["n"][l]] * (Lℷ["M"][l] * Z[t, l] - ζ[t, l]) for l in 1:L) >= -Bℷ["BC"][b]
    )
    JuMP.@constraint(ø, ℵbr[t = 1:T, b = 1:B],
        Bℷ["BC"][b] >= sum(F[b, Gℷ["n"][g]] * p[t, g] for g in 1:G) + sum(F[b, Wℷ["n"][w]] * (Wℷ["M"][w] * Y[t, w] - ϖ[t, w]) for w in 1:W) - sum(F[b, Lℷ["n"][l]] * (Lℷ["M"][l] * Z[t, l] - ζ[t, l]) for l in 1:L)
    )
    JuMP.@constraint(ø, ℵR[t = 1:T], sum(ρ[t, :]) >= SRD)
    JuMP.@constraint(ø, ℵ0[t = 1:T], sum(Wℷ["M"][w] * Y[t, w] - ϖ[t, w] for w in 1:W) + sum(p[t, :]) - sum(Lℷ["M"][l] * Z[t, l] - ζ[t, l] for l in 1:L) >= 0.)
    JuMP.@expression(ø, CP[t = 1:T], sum(Wℷ["M"][w] * Y[t, w] - ϖ[t, w] for w in 1:W) + sum(p[t, :]) - sum(Lℷ["M"][l] * Z[t, l] - ζ[t, l] for l in 1:L))
    JuMP.@expression(ø, CW[t = 1:T, w = 1:W], Wℷ["CW"][t, w] * ϖ[t, w])
    JuMP.@expression(ø, CL[t = 1:T, l = 1:L], Lℷ["CL"][t, l] * ζ[t, l])
    JuMP.@expression(ø, CR[t = 1:T, g = 1:G], Gℷ["CR"][g]    * ρ[t, g])
    JuMP.@expression(ø, COST2, sum(CW) + sum(CL) + sum(CR) + sum(e) + PE * sum(CP))
    JuMP.@objective(ø, Min, COST1 + COST2)
end

function f_slacked_primal()
    JuMP.@variable(ø, s1[g = 1:G]          >= 0.)
    JuMP.@variable(ø, s2[t = 2:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, s3[t = 1:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, s4[t = 1:T, b = 1:B] >= 0.)
    JuMP.@variable(ø, s5[t = 1:T, b = 1:B] >= 0.)
    # always feasible part
    JuMP.@variable(ø,  ϖ[t = 1:T, w = 1:W] >= 0.)
    JuMP.@variable(ø,  ζ[t = 1:T, l = 1:L] >= 0.)
    JuMP.@variable(ø,  ρ[t = 1:T, g = 1:G] >= 0.)
    JuMP.@variable(ø,  p[t = 1:T, g = 1:G])
    JuMP.@constraint(ø, ℵW[t = 1:T, w = 1:W], Wℷ["M"][w] * Y[t, w] >= ϖ[t, w])
    JuMP.@constraint(ø, ℵL[t = 1:T, l = 1:L], Lℷ["M"][l] * Z[t, l] >= ζ[t, l])
    JuMP.@constraint(ø, ℵdl1[g = 1:G], p[1, g] - Gℷ["ZP"][g]       >= -Gℷ["RD"][g] * x[1, g] - Gℷ["SD"][g] * v[1, g])
    JuMP.@constraint(ø, ℵdl[t = 2:T, g = 1:G], p[t, g] - p[t-1, g] >= -Gℷ["RD"][g] * x[t, g] - Gℷ["SD"][g] * v[t, g])
    JuMP.@constraint(ø, ℵR[t = 1:T], sum(ρ[t, :]) >= SRD)
    JuMP.@constraint(ø, ℵ0[t = 1:T], sum(Wℷ["M"][w] * Y[t, w] - ϖ[t, w] for w in 1:W) + sum(p[t, :]) - sum(Lℷ["M"][l] * Z[t, l] - ζ[t, l] for l in 1:L) >= 0.)
    JuMP.@constraint(ø, ℵPI[t = 1:T, g = 1:G], p[t, g] >= Gℷ["PI"][g] * x[t, g])
    # slacked part
    JuMP.@constraint(ø, ℵdr1[g = 1:G], s1[g] + Gℷ["RU"][g] * Gℷ["ZS"][g] + Gℷ["SU"][g] * u[1, g]       >= p[1, g] - Gℷ["ZP"][g])
    JuMP.@constraint(ø, ℵdr[t = 2:T, g = 1:G], s2[t, g] + Gℷ["RU"][g] * x[t-1, g] + Gℷ["SU"][g] * u[t, g] >= p[t, g] - p[t-1, g])
    JuMP.@constraint(ø, ℵPS[t = 1:T, g = 1:G], s3[t, g] + Gℷ["PS"][g] * x[t, g] >= p[t, g] + ρ[t, g])
    JuMP.@constraint(ø, ℵbl[t = 1:T, b = 1:B],
        s4[t, b] + sum(F[b, Gℷ["n"][g]] * p[t, g] for g in 1:G) + sum(F[b, Wℷ["n"][w]] * (Wℷ["M"][w] * Y[t, w] - ϖ[t, w]) for w in 1:W) - sum(F[b, Lℷ["n"][l]] * (Lℷ["M"][l] * Z[t, l] - ζ[t, l]) for l in 1:L) >= -Bℷ["BC"][b]
    )
    JuMP.@constraint(ø, ℵbr[t = 1:T, b = 1:B],
        s5[t, b] + Bℷ["BC"][b] >= sum(F[b, Gℷ["n"][g]] * p[t, g] for g in 1:G) + sum(F[b, Wℷ["n"][w]] * (Wℷ["M"][w] * Y[t, w] - ϖ[t, w]) for w in 1:W) - sum(F[b, Lℷ["n"][l]] * (Lℷ["M"][l] * Z[t, l] - ζ[t, l]) for l in 1:L)
    )
    JuMP.@objective(ø, Min, sum(s1) + sum(s2) + sum(s3) + sum(s4) + sum(s5))
end

function f_dual( there is an additional -ip(beta2, Z) in the outer layer!!! )
    JuMP.@variable(ø, ℵQ1[t = 1:T, g = 1:G])
    JuMP.@variable(ø, ℵQ2[t = 1:T, g = 1:G])
    JuMP.@variable(ø, ℵQ3[t = 1:T, g = 1:G])
    JuMP.@variable(ø, ℵW[t = 1:T, w = 1:W] >= 0.)
    JuMP.@variable(ø, ℵL[t = 1:T, l = 1:L] >= 0.)
    JuMP.@variable(ø, 0. <= ℵe[t = 1:T, g = 1:G] <= 1.) # RHS due to e >= 0
    JuMP.@variable(ø, ℵdl1[g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵdl[t = 2:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵdr1[g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵdr[t = 2:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵPI[t = 1:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵPS[t = 1:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵbl[t = 1:T, b = 1:B] >= 0.)
    JuMP.@variable(ø, ℵbr[t = 1:T, b = 1:B] >= 0.)
    JuMP.@variable(ø, ℵR[t = 1:T] >= 0.)
    JuMP.@variable(ø, ℵ0[t = 1:T] >= 0.)
    JuMP.@constraint(ø,  ϖ[t = 1:T, w = 1:W],  ℵ0[t] + ℵW[t, w] + Wℷ["CW"][t, w] - PE + sum(F[b, Wℷ["n"][w]] * (ℵbl[t, b] - ℵbr[t, b]) for b in 1:B) >= 0.)
    JuMP.@constraint(ø,  ζ[t = 1:T, l = 1:L], -ℵ0[t] + ℵL[t, l] + Lℷ["CL"][t, l] + PE + sum(F[b, Lℷ["n"][l]] * (ℵbr[t, b] - ℵbl[t, b]) for b in 1:B) >= 0.)
    JuMP.@constraint(ø,  ρ[t = 1:T, g = 1:G], ℵPS[t, g] - ℵR[t] + Gℷ["CR"][g] >= 0.)
    JuMP.@constraint(ø, p²[t = 1:T, g = 1:G], Gℷ["C2"][g] * ℵe[t, g] - ℵQ2[t, g] - ℵQ1[t, g] == 0.)
    JuMP.@expression(ø,  pCommon[t = 1:T, g = 1:G], ℵPS[t, g] - ℵPI[t, g] - ℵ0[t] - 2. * ℵQ3[t, g] + Gℷ["C1"][g] * ℵe[t, g] + PE + sum((ℵbr[t, b] - ℵbl[t, b]) * F[b, Gℷ["n"][g]] for b in 1:B))
    JuMP.@constraint(ø,  pt1[g = 1:G], pCommon[1, g] + ℵdr1[g] - ℵdl1[g] + ℵdl[2, g] - ℵdr[2, g] == 0.)
    JuMP.@constraint(ø,  prest[t = 2:T-1, g = 1:G], pCommon[t, g] + ℵdr[t, g] - ℵdl[t, g] + ℵdl[t+1, g] - ℵdr[t+1, g] == 0.)
    JuMP.@constraint(ø,  ptT[g = 1:G], pCommon[T, g] + ℵdr[T, g] - ℵdl[T, g] == 0.)
    JuMP.@constraint(ø, [t = 1:T, g = 1:G], [ℵQ1[t, g], ℵQ2[t, g], ℵQ3[t, g]] in JuMP.SecondOrderCone())
    JuMP.@objective(ø, Max, PE * sum(sum(Wℷ["M"][w] * Y[t, w] for w in 1:W) - sum(Lℷ["M"][l] * Z[t, l]  for l in 1:L) for t in 1:T)
        + sum(ℵQ2 .- ℵQ1) + sum(ℵe[t, g] * (Gℷ["C0"][g] - (1 - x[t, g]) * Gℷ["M"][g]) for t in 1:T, g in 1:G)
        - sum(ℵW[t, w] * Wℷ["M"][w] * Y[t, w] for t in 1:T, w in 1:W) - sum(ℵL[t, l] * Lℷ["M"][l] * Z[t, l] for t in 1:T, l in 1:L)
        + SRD * sum(ℵR) + sum( ℵPI[t, g] * Gℷ["PI"][g] * x[t, g] - ℵPS[t, g] * Gℷ["PS"][g] * x[t, g]  for t in 1:T, g in 1:G)
        + sum((ℵbr[t, b] - ℵbl[t, b]) * (sum(F[b, Wℷ["n"][w]] * Wℷ["M"][w] * Y[t, w] for w in 1:W) - sum(F[b, Lℷ["n"][l]] * Lℷ["M"][l] * Z[t, l] for l in 1:L)) for t in 1:T, b in 1:B)
        + sum((ℵbl[t, b] + ℵbr[t, b]) * (-Bℷ["BC"][b]) for t in 1:T, b in 1:B)
        + sum( ℵ0[t] * (sum(Lℷ["M"][l] * Z[t, l] for l in 1:L) - sum(Wℷ["M"][w] * Y[t, w] for w in 1:W)) for t in 1:T)
        + sum(ℵdl1[g] * (Gℷ["ZP"][g] - Gℷ["RD"][g] * x[1, g] - Gℷ["SD"][g] * v[1, g]) - ℵdr1[g] * (Gℷ["RU"][g] * Gℷ["ZS"][g] + Gℷ["SU"][g] * u[1, g] + Gℷ["ZP"][g]) for g in 1:G)
        + sum( ℵdl[t, g] * (-Gℷ["RD"][g] * x[t, g] - Gℷ["SD"][g] * v[t, g]) - ℵdr[t, g] * (Gℷ["RU"][g] * x[t-1, g] + Gℷ["SU"][g] * u[t, g]) for t in 2:T, g in 1:G)
    )
end

function f_slacked_dual()
    JuMP.@variable(ø, ℵW[t = 1:T, w = 1:W] >= 0.)
    JuMP.@variable(ø, ℵL[t = 1:T, l = 1:L] >= 0.)
    JuMP.@variable(ø, ℵdl1[g = 1:G] >= 0.)
    JuMP.@variable(ø, ℵdl[t = 2:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, 0. <= ℵdr1[g = 1:G] <= 1.)
    JuMP.@variable(ø, 0. <= ℵdr[t = 2:T, g = 1:G] <= 1.)
    JuMP.@variable(ø, ℵPI[t = 1:T, g = 1:G] >= 0.)
    JuMP.@variable(ø, 0. <= ℵPS[t = 1:T, g = 1:G] <= 1.)
    JuMP.@variable(ø, 0. <= ℵbl[t = 1:T, b = 1:B] <= 1.)
    JuMP.@variable(ø, 0. <= ℵbr[t = 1:T, b = 1:B] <= 1.)
    JuMP.@variable(ø, ℵR[t = 1:T] >= 0.)
    JuMP.@variable(ø, ℵ0[t = 1:T] >= 0.)
    JuMP.@constraint(ø,  ϖ[t = 1:T, w = 1:W],  ℵ0[t] + ℵW[t, w] + sum(F[b, Wℷ["n"][w]] * (ℵbl[t, b] - ℵbr[t, b]) for b in 1:B) >= 0.)
    JuMP.@constraint(ø,  ζ[t = 1:T, l = 1:L], -ℵ0[t] + ℵL[t, l] + sum(F[b, Lℷ["n"][l]] * (ℵbr[t, b] - ℵbl[t, b]) for b in 1:B) >= 0.)
    JuMP.@constraint(ø,  ρ[t = 1:T, g = 1:G], ℵPS[t, g] - ℵR[t] >= 0.)
    JuMP.@expression(ø,  pCommon[t = 1:T, g = 1:G], ℵPS[t, g] - ℵPI[t, g] - ℵ0[t] + sum((ℵbr[t, b] - ℵbl[t, b]) * F[b, Gℷ["n"][g]] for b in 1:B))
    JuMP.@constraint(ø,  pt1[g = 1:G], pCommon[1, g] + ℵdr1[g] - ℵdl1[g] + ℵdl[2, g] - ℵdr[2, g] == 0.)
    JuMP.@constraint(ø,  prest[t = 2:T-1, g = 1:G], pCommon[t, g] + ℵdr[t, g] - ℵdl[t, g] + ℵdl[t+1, g] - ℵdr[t+1, g] == 0.)
    JuMP.@constraint(ø,  ptT[g = 1:G], pCommon[T, g] + ℵdr[T, g] - ℵdl[T, g] == 0.)
    JuMP.@objective(ø, Max, -sum(ℵW[t, w] * Wℷ["M"][w] * Y[t, w] for t in 1:T, w in 1:W) - sum(ℵL[t, l] * Lℷ["M"][l] * Z[t, l] for t in 1:T, l in 1:L)
        + SRD * sum(ℵR) + sum( ℵPI[t, g] * Gℷ["PI"][g] * x[t, g] - ℵPS[t, g] * Gℷ["PS"][g] * x[t, g]  for t in 1:T, g in 1:G)
        + sum((ℵbr[t, b] - ℵbl[t, b]) * (sum(F[b, Wℷ["n"][w]] * Wℷ["M"][w] * Y[t, w] for w in 1:W) - sum(F[b, Lℷ["n"][l]] * Lℷ["M"][l] * Z[t, l] for l in 1:L)) for t in 1:T, b in 1:B)
        + sum((ℵbl[t, b] + ℵbr[t, b]) * (-Bℷ["BC"][b]) for t in 1:T, b in 1:B)
        + sum( ℵ0[t] * (sum(Lℷ["M"][l] * Z[t, l] for l in 1:L) - sum(Wℷ["M"][w] * Y[t, w] for w in 1:W)) for t in 1:T)
        + sum(ℵdl1[g] * (Gℷ["ZP"][g] - Gℷ["RD"][g] * x[1, g] - Gℷ["SD"][g] * v[1, g]) - ℵdr1[g] * (Gℷ["RU"][g] * Gℷ["ZS"][g] + Gℷ["SU"][g] * u[1, g] + Gℷ["ZP"][g]) for g in 1:G)
        + sum( ℵdl[t, g] * (-Gℷ["RD"][g] * x[t, g] - Gℷ["SD"][g] * v[t, g]) - ℵdr[t, g] * (Gℷ["RU"][g] * x[t-1, g] + Gℷ["SU"][g] * u[t, g]) for t in 2:T, g in 1:G)
    )
end

