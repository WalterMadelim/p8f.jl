# import PowerModels # to parse Matpower *.m data files
import LinearAlgebra
import Distributions
import Random
import Gurobi
import JuMP
using Logging

# add cut to a convex function only if the current trial point violates the cut to be addd
# trial point is generated by lb
PTH = 1e-4
Random.seed!(23)
global_logger(ConsoleLogger(Info))
GRB_ENV = Gurobi.Env()
function ip(x, y) return LinearAlgebra.dot(x, y) end
function JumpModel(i)
    if i == 0 # the most frequently used
        m = JuMP.Model(() -> Gurobi.Optimizer(GRB_ENV))
    elseif i == 1 # generic convex conic program
        m = JuMP.Model(MosekTools.Optimizer)
    elseif i == 2 # if you need Gurobi callback
        m = JuMP.direct_model(Gurobi.Optimizer(GRB_ENV))
    end
    JuMP.set_silent(m) # use JuMP.unset_silent(m) to debug when it is needed
    return m
end
function load_data()
    # network_data = PowerModels.parse_file("data/case6ww.m")
    # basic_net_data = PowerModels.make_basic_network(network_data)
    # F = PowerModels.calc_basic_ptdf_matrix(basic_net_data)
    S_BASE = 100 # MVA
    F = [0.0 -0.44078818231301325 -0.3777905547603966 -0.2799660317280192 -0.29542103345397086 -0.3797533556433226; 0.0 -0.32937180203296385 -0.3066763814017814 -0.5368505424397501 -0.27700207451336545 -0.30738349678665927; 0.0 -0.229840015654023 -0.3155330638378219 -0.18318342583223077 -0.42757689203266364 -0.31286314757001815; 0.0 0.06057464187751593 -0.354492865935812 0.018549141862024054 -0.10590781852459258 -0.20249230420747694; 0.0 0.3216443011699881 0.23423126113776493 -0.3527138586915366 0.11993854023522055 0.23695476674932447; 0.0 0.10902536164428178 -0.020830957469362865 0.03338570129374399 -0.19061834882900958 -0.016785057525005476; 0.0 0.0679675129952012 -0.23669799249298656 0.02081298380774932 -0.11883340633558914 -0.39743076066016436; 0.0 0.06529291323070335 0.270224001096538 0.019993968970548615 -0.11415717519819152 0.1491923753527435; 0.0 -0.004718271353187364 0.3752831329676507 -0.001444827108524449 0.00824935667359894 -0.35168467956022; 0.0 -0.007727500862975828 -0.07244512026401648 0.11043559886871346 -0.15706353427814482 -0.0704287300373348; 0.0 -0.06324924164201379 -0.13858514047466358 -0.019368156699224842 0.11058404966199031 -0.2508845597796152]
    Bℶ = Dict(
        "f" =>  Int[1,1,1,2,2,2,2,3,3,4,5],
        "t" =>  Int[2,4,5,3,4,5,6,5,6,5,6],
        "BC" => [4,6,4,4,6,3,9,7,8,2,4]/10
    ) # lines
    Wℶ = Dict(
        "id" => Int[1, 2],
        "n" => Int[2, 3],
        "CW" => [500., 400],
        "MAX" => [1.8, 1.7]
    ) # wind
    Lℶ = Dict(
        "id" => Int[1,2,3],
        "n" => Int[4,5,6],
        "CL" => 1.8 * [3000., 2583, 2708],
        "MAX" => [1, 1.2, 1]
    ) # load
    Gℶ = Dict(
        "id" => Int[1, 2, 3], # the 1st one is slack generator
        "n" => Int[1, 2, 3], # the 1st generator resides at bus 1
        "ZS" => [1., 0, 0], # the 1st generator is always on
        "ZP" => [0.5, 0, 0], # Pzero, consistent with IS
        "C2" => [53.3, 88.9, 74.1],
        "C1" => [1166.9, 1033.3, 1083.3],
        "C0" => [0., 200, 240], # the 1st generator has no generation cost if output power = 0
        "CR" => [83., 74, 77],
        "CST" => [210., 200, 240],
        "CSH" => [210., 200, 240],
        "PI" => [0., 0.375, 0.45], # the 1st generator doesn't have a positive output lower bound
        "PS" => [2, 1.5, 1.8],
        "RU" => [.6, .6, .6],
        "SU" => [.6, .6, .6],
        "RD" => [.6, .6, .6],
        "SD" => [.6, .6, .6],
        "UT" => Int[3, 3, 3],
        "DT" => Int[3, 3, 3]
    )
    G = length(Gℶ["n"])
    W = length(Wℶ["n"])
    L = length(Lℶ["n"])
    B, N = size(F)
    SRD = 1.5 # system reserve demand
    return B, G, W, L, F, SRD, Bℶ, Gℶ, Wℶ, Lℶ
end

B, G, W, L, F, SRD, Bℶ, Gℶ, Wℶ, Lℶ = load_data()
MY = [0.654662 0.641636; 0.656534 0.819678; 0.511227 0.392445; 0.435808 0.123746; 0.100096 0.35382; 0.782138 0.542857; 0.798238 0.76052; 0.39923 0.309604]
MZ = [[0.7310,0.4814,0.6908,0.4326,0.1753,0.8567,0.8665,0.6107] [0.7010,0.5814,0.3908,0.1326,0.4153,0.7567,0.8565,0.5107] [0.2010,0.6814,0.1908,0.4326,0.8153,0.7567,0.6565,0.7107]]
T = 8

if true # cutDict pertinent
    function gencℶ()
        return Dict(
            "pu" => JuMP.Containers.DenseAxisArray[],
            "pv" => JuMP.Containers.DenseAxisArray[],
            "px" => JuMP.Containers.DenseAxisArray[],
            "cn" => Float64[],
            "u" => JuMP.Containers.DenseAxisArray[],
            "v" => JuMP.Containers.DenseAxisArray[],
            "x" => JuMP.Containers.DenseAxisArray[],
        )
    end
    function gencℶY()
        return Dict(
            "pY" => Matrix[], # i.e. ak
            "Y" => Matrix[] # 🔧 the r.v.
        )
    end
    function gencℶZ()
        return Dict(
            "pZ" => Matrix[], # i.e. ak
            "Z" => Matrix[] # 🔧 the r.v.
        )
    end
    function lengthcℶ(cℶ) return length(cℶ["cn"]) end
    cf2ℶ = merge(gencℶ(), gencℶY(), gencℶZ()) # "Z" 🔧 the r.v.
    cf1ℶ = merge(gencℶ(), gencℶZ(), gencℶY()) # "Y" 🔧 the r.v.
    chb2ℶ = merge(gencℶ(), gencℶY()) # "Y" 🔧 the r.v.
    chb1ℶ = merge(gencℶ(), gencℶZ()) # "Z" 🔧 the r.v.
    cbh2ℶ, cbh1ℶ, cuhℶ, cfeasℶ = gencℶ(), gencℶ(), gencℶ(), gencℶ()
    function pushcℶ(cℶ, pu, pv, px, cn, u, v, x) # for `cuhℶ`, `cbh2ℶ`, `cbh1ℶ`, `cfeasℶ`
        push!(cℶ["pu"], pu)
        push!(cℶ["pv"], pv)
        push!(cℶ["px"], px)
        push!(cℶ["cn"], cn)
        push!(cℶ["u"], u)
        push!(cℶ["v"], v)
        push!(cℶ["x"], x)
    end
    function pushcℶ(cℶ, pu, pv, px, pY, pZ, cn, u, v, x, Y, Z) # for `cf1ℶ` and `cf1ℶ`
        push!(cℶ["pY"], pY)
        push!(cℶ["Y"], Y)
        push!(cℶ["pZ"], pZ)
        push!(cℶ["Z"], Z)
        pushcℶ(cℶ, pu, pv, px, cn, u, v, x)
    end
    function pushcℶY(cℶ, pu, pv, px, pY, cn, u, v, x, Y)
        push!(cℶ["pY"], pY)
        push!(cℶ["Y"], Y)
        pushcℶ(cℶ, pu, pv, px, cn, u, v, x)
    end
end
function master(cℶ, set_lb)
    ø = JumpModel(0)
    JuMP.@variable(ø, u[1:T, 2:G], Bin)
    JuMP.@variable(ø, v[1:T, 2:G], Bin)
    JuMP.@variable(ø, x[0:T, 2:G], Bin)
    JuMP.@expression(ø, CGst[t = 1:T, g = 2:G], Gℶ["CST"][g] * u[t, g])
    JuMP.@expression(ø, CGsh[t = 1:T, g = 2:G], Gℶ["CSH"][g] * v[t, g])
    JuMP.@expression(ø, COST1, sum(CGst) + sum(CGsh))
    JuMP.@constraint(ø, [t = 1:T, g = 2:G], x[t, g] - x[t-1, g] == u[t, g] - v[t, g]) # linking constr, but authentic 1st stage
    [   JuMP.fix(x[0, g], Gℶ["ZS"][g]; force = true) for g in 2:G   ]
    JuMP.@constraint(ø, [g = 2:G, t = 1:T-Gℶ["UT"][g]+1], sum(x[i, g] for i in t:t+Gℶ["UT"][g]-1) >= Gℶ["UT"][g] * u[t, g])
    JuMP.@constraint(ø, [g = 2:G, t = T-Gℶ["UT"][g]+1:T], sum(x[i, g] - u[t, g] for i in t:T) >= 0.)
    JuMP.@constraint(ø, [g = 2:G, t = 1:T-Gℶ["DT"][g]+1], sum(1. - x[i, g] for i in t:t+Gℶ["DT"][g]-1) >= Gℶ["DT"][g] * v[t, g])
    JuMP.@constraint(ø, [g = 2:G, t = T-Gℶ["DT"][g]+1:T], sum(1. - x[i, g] - v[t, g] for i in t:T) >= 0.)
    ℶ = cfeasℶ
    for (pu, pv, px, cn, ut, vt, xt) in zip(ℶ["pu"], ℶ["pv"], ℶ["px"], ℶ["cn"], ℶ["u"], ℶ["v"], ℶ["x"])
        JuMP.@constraint(ø, 0. >= cn + ip(pu, u .- ut) + ip(pv, v .- vt) + ip(px, x .- xt)) # 👍 Benders' Feas. cut
    end
    JuMP.@variable(ø, o) # the trial value to be cut off at the next iteration
    for (pu, pv, px, cn) in zip(cℶ["pu"], cℶ["pv"], cℶ["px"], cℶ["cn"])
        JuMP.@constraint(ø, o >= cn + ip(pu, u) + ip(pv, v) + ip(px, x)) # 👍 sup's cut
    end
    JuMP.@variable(ø, objterm)
    set_lb && JuMP.set_lower_bound(objterm, -3.)
    JuMP.@constraint(ø, objterm >= COST1 + o)
    JuMP.@objective(ø, Min, objterm)
    JuMP.optimize!(ø)
    status = JuMP.termination_status(ø)
    @assert status == JuMP.OPTIMAL "in master(), status = $status"
    return JuMP.value(o), JuMP.value.(u), JuMP.value.(v), JuMP.value.(x), JuMP.value(objterm), JuMP.value(COST1)
end
function get_o(cℶ, u, v, x) # for cbh2ℶ or cbh1ℶ
    ø = JumpModel(0)
    JuMP.@variable(ø, o)
    for (pu, pv, px, cn) in zip(cℶ["pu"], cℶ["pv"], cℶ["px"], cℶ["cn"])
        JuMP.@constraint(ø, o >= cn + ip(pu, u) + ip(pv, v) + ip(px, x))
    end
    JuMP.@objective(ø, Min, o)
    JuMP.optimize!(ø)
    status = JuMP.termination_status(ø)
    @assert status == JuMP.OPTIMAL "in get_o(), status = $status"
    return JuMP.value(o)
end
function RC2Y(u, v, x, MY, isbwd) # utilize `chb2ℶ` & generate trial Y ~ Q & preparing cut for `cbh2ℶ`
    cℶ = chb2ℶ # \ref{chb2ℶ}
    K = lengthcℶ(cℶ)
    function a(k) return cℶ["pY"][k] end
    function b(k, u, v, x) return ip(cℶ["pu"][k], u) + ip(cℶ["pv"][k], v) + ip(cℶ["px"][k], x) + cℶ["cn"][k] end
    ø = JumpModel(0)
    JuMP.@variable(ø, α)
    JuMP.@variable(ø, β[1:T, 1:W])
    JuMP.@objective(ø, Min, α + ip(MY, β))
    JuMP.@variable(ø, ς[1:K, 1:T, 1:W] >= 0.)
    JuMP.@constraint(ø, η[k = 1:K], α >= b(k, u, v, x) + sum(ς[k, :, :]))
    JuMP.@constraint(ø, ξ[k = 1:K, t = 1:T, w = 1:W], β[t, w] + ς[k, t, w] >= a(k)[t, w])
    JuMP.optimize!(ø)
    status = JuMP.termination_status(ø)
    @assert status == JuMP.OPTIMAL "in RC2Y, status = $status"
    η, ξ = JuMP.dual.(η)::Vector, JuMP.dual.(ξ)::Array
    if isbwd # (sup's) cut preparation o >= cn + <pu, u> + <pv, v> + <px, x>
        pu = sum(η[k] .* cℶ["pu"][k] for k in 1:K)
        pv = sum(η[k] .* cℶ["pv"][k] for k in 1:K)
        px = sum(η[k] .* cℶ["px"][k] for k in 1:K)
        cn = sum(η[k]  * cℶ["cn"][k] + ip(ξ[k, :, :], a(k)) for k in 1:K)
        return JuMP.objective_value(ø), (pu, pv, px, cn, u, v, x) # \label{cbh2ℶ}
    else # generate trial Y ~ Q
        bitvec = η .> PTH # eliminate 0's
        η, ξ = η[bitvec], ξ[bitvec, :, :]
        Ytrial = [ξ[i, r, c] / η[i] for i in eachindex(η), r in 1:size(ξ)[2], c in 1:size(ξ)[3]]
        return JuMP.objective_value(ø), (η, Ytrial)
    end
end
function RC2Z(u, v, x, Y, MZ, isbwd) # utilize `cf2ℶ` & generate trial Z ~ P & preparing cut for `chb2ℶ`
    cℶ = cf2ℶ 
    K = lengthcℶ(cℶ)
    function a(k) return cℶ["pZ"][k] end
    function b(k, u, v, x, Y) return ip(cℶ["pu"][k], u) + ip(cℶ["pv"][k], v) + ip(cℶ["px"][k], x) + ip(cℶ["pY"][k], Y) + cℶ["cn"][k] end
    ø = JumpModel(0)
    JuMP.@variable(ø, α)
    JuMP.@variable(ø, β[1:T, 1:L])
    JuMP.@objective(ø, Min, α + ip(MZ, β))
    JuMP.@variable(ø, ς[1:K, 1:T, 1:L] >= 0.)
    JuMP.@constraint(ø, η[k = 1:K], α >= b(k, u, v, x, Y) + sum(ς[k, :, :]))
    JuMP.@constraint(ø, ξ[k = 1:K, t = 1:T, l = 1:L], β[t, l] + ς[k, t, l] >= a(k)[t, l])
    JuMP.optimize!(ø)
    status = JuMP.termination_status(ø)
    @assert status == JuMP.OPTIMAL "in RC2Z, status = $status"
    η, ξ = JuMP.dual.(η)::Vector, JuMP.dual.(ξ)::Array
    if isbwd # (sup's) cut preparation o >= cn + <pu, u> + <pv, v> + <px, x> + <pY, Y>
        pu = sum(η[k] .* cℶ["pu"][k] for k in 1:K)
        pv = sum(η[k] .* cℶ["pv"][k] for k in 1:K)
        px = sum(η[k] .* cℶ["px"][k] for k in 1:K)
        pY = sum(η[k] .* cℶ["pY"][k] for k in 1:K)
        cn = sum(η[k]  * cℶ["cn"][k] + ip(ξ[k, :, :], a(k)) for k in 1:K)
        return JuMP.objective_value(ø), (pu, pv, px, pY, cn, u, v, x, Y) # \label{chb2ℶ}
    else # generate trial Z ~ P
        bitvec = η .> PTH # eliminate 0's
        η, ξ = η[bitvec], ξ[bitvec, :, :]
        Ztrial = [ξ[i, r, c] / η[i] for i in eachindex(η), r in 1:size(ξ)[2], c in 1:size(ξ)[3]]
        return JuMP.objective_value(ø), (η, Ztrial)
    end
end
function f(uu, vv, xx, YY, ZZ) # preparing cut derived from Benders' cut
    function θ(g, p) return Gℶ["C2"][g] * p^2 + Gℶ["C1"][g] * p + Gℶ["C0"][g] end
    ø = JumpModel(0)
    JuMP.@variable(ø, u[1:T, 2:G])
    JuMP.@variable(ø, v[1:T, 2:G])
    JuMP.@variable(ø, x[0:T, 2:G])
    JuMP.@variable(ø, Y[1:T, 1:W])
    JuMP.@variable(ø, Z[1:T, 1:L])
    JuMP.@constraint(ø, ℵu[t = 1:T, g = 2:G], u[t, g] == uu[t, g])
    JuMP.@constraint(ø, ℵv[t = 1:T, g = 2:G], v[t, g] == vv[t, g])
    JuMP.@constraint(ø, ℵx[t = 0:T, g = 2:G], x[t, g] == xx[t, g])
    JuMP.@constraint(ø, ℵY[t = 1:T, w = 1:W], Y[t, w] == YY[t, w])
    JuMP.@constraint(ø, ℵZ[t = 1:T, l = 1:L], Z[t, l] == ZZ[t, l])
    JuMP.@variable(ø, ϖ[1:T, 1:W] >= 0.)
    JuMP.@variable(ø, ζ[1:T, 1:L] >= 0.)
    JuMP.@expression(ø, CW[t = 1:T, w = 1:W], Wℶ["CW"][w] * ϖ[t, w])
    JuMP.@expression(ø, CL[t = 1:T, l = 1:L], Lℶ["CL"][l] * ζ[t, l])
    JuMP.@constraint(ø, ℵϖ[t = 1:T, w in 1:W], ϖ[t, w] - Wℶ["MAX"][w] * Y[t, w] <= 0.)
    JuMP.@constraint(ø, ℵζ[t = 1:T, l in 1:L], ζ[t, l] - Lℶ["MAX"][l] * Z[t, l] <= 0.)
    JuMP.@variable(ø, ρ[1:T, 1:G] >= 0.)
    JuMP.@expression(ø, CGres[t = 1:T, g = 1:G], Gℶ["CR"][g] * ρ[t, g])
    JuMP.@variable(ø, ϱ[1:T] >= 0.)
    JuMP.@variable(ø, ϱsq[1:T])
    JuMP.@constraint(ø, [t = 1:T], [ϱsq[t] + 1, ϱsq[t] - 1, 2 * ϱ[t]] in JuMP.SecondOrderCone()) # 🍧
    JuMP.@expression(ø, CGgen1[t = 1:T], Gℶ["C2"][1] * ϱsq[t] + Gℶ["C1"][1] * ϱ[t])
    JuMP.@variable(ø, p[0:T, 2:G]) # power output of the Generator 2:G
    [ JuMP.fix(p[0, g], Gℶ["ZP"][g]; force = true) for g in 2:G ]
    JuMP.@variable(ø, psq[1:T, 2:G])
    JuMP.@constraint(ø, [t = 1:T, g = 2:G], [psq[t, g] + 1, psq[t, g] - 1, 2 * p[t, g]] in JuMP.SecondOrderCone()) # 🍧
    JuMP.@expression(ø, CGgen2[t = 1:T, g = 2:G], Gℶ["C2"][g] * psq[t, g] + Gℶ["C1"][g] * p[t, g] + Gℶ["C0"][g])
    JuMP.@variable(ø, ϕ[1:T, 2:G] >= 0.) # epi-variable of Cost_Generators, only for 2:G
    JuMP.@constraint(ø, ℵϕ[t = 1:T, g = 2:G], CGgen2[t, g] - (1. - x[t, g]) * θ(g, Gℶ["PS"][g]) - ϕ[t, g] <= 0.)
    JuMP.@constraint(ø, ℵdpl[t = 1:T, g = 2:G], -Gℶ["RD"][g] * x[t, g] - Gℶ["SD"][g] * v[t, g] + p[t-1, g] - p[t, g] <= 0.)
    JuMP.@constraint(ø, ℵdpr[t = 1:T, g = 2:G], p[t, g] - p[t-1, g] - Gℶ["RU"][g] * x[t-1, g] - Gℶ["SU"][g] * u[t, g] <= 0.)
    JuMP.@constraint(ø, ℵSRD[t = 1:T], SRD - sum(ρ[t, :]) <= 0.)
    JuMP.@constraint(ø, ℵϱ[t = 1:T], ϱ[t] + ρ[t, 1] - Gℶ["PS"][1] <= 0.)
    JuMP.@constraint(ø, ℵPI[t = 1:T, g = 2:G], Gℶ["PI"][g] * x[t, g] - p[t, g] <= 0.)
    JuMP.@constraint(ø, ℵPS[t = 1:T, g = 2:G], p[t, g] + ρ[t, g] - Gℶ["PS"][g] * x[t, g] <= 0.)
    JuMP.@expression(ø, line_flow[t = 1:T, b = 1:B], sum(F[b, Wℶ["n"][w]] * (Wℶ["MAX"][w] * Y[t, w] - ϖ[t, w]) for w in 1:W) + 
                                                sum(F[b, Gℶ["n"][g]] * p[t, g] for g in 2:G)
                                                - sum(F[b, Lℶ["n"][l]] * (Lℶ["MAX"][l] * Z[t, l] - ζ[t, l]) for l in 1:L))
    JuMP.@constraint(ø, ℵlfl[t = 1:T, b = 1:B], -Bℶ["BC"][b] <= line_flow[t, b])
    JuMP.@constraint(ø, ℵlfr[t = 1:T, b = 1:B], line_flow[t, b] <= Bℶ["BC"][b])
    JuMP.@constraint(ø, ℵbalance[t = 1:T], sum(Wℶ["MAX"][w] * Y[t, w] - ϖ[t, w] for w in 1:W) + sum(p[t, :]) + ϱ[t] == sum(Lℶ["MAX"][l] * Z[t, l] - ζ[t, l] for l in 1:L))
    JuMP.@objective(ø, Min, sum(CW) + sum(CL) + sum(CGres) + sum(CGgen1) + sum(ϕ))
    JuMP.set_attribute(ø, "QCPDual", 1)
    JuMP.optimize!(ø)
    status = JuMP.termination_status(ø)
    if status == JuMP.OPTIMAL
        objVal = JuMP.objective_value(ø)
        pu, pv, px, pY, pZ = JuMP.dual.(ℵu), JuMP.dual.(ℵv), JuMP.dual.(ℵx), JuMP.dual.(ℵY), JuMP.dual.(ℵZ)
        cn = objVal - (ip(pu, uu) + ip(pv, vv) + ip(px, xx) + ip(pY, YY) + ip(pZ, ZZ))
        return objVal, (pu, pv, px, pY, pZ, cn, uu, vv, xx, YY, ZZ) # optimality cut
    else
        if status == JuMP.INFEASIBLE_OR_UNBOUNDED
            JuMP.set_attribute(ø, "DualReductions", 0)
            JuMP.optimize!(ø)
            status = JuMP.termination_status(ø)
            @assert status == JuMP.INFEASIBLE "in f(1), status = $status"
        end
        if status == JuMP.INFEASIBLE
            [JuMP.delete.(ø, ℵbalance), JuMP.unregister(ø, :ℵbalance)]
            JuMP.@variable(ø, s3[t = 1:T] >= 0.)
            JuMP.@variable(ø, s4[t = 1:T] >= 0.)
            JuMP.@constraint(ø, [t = 1:T], sum(Wℶ["MAX"][w] * Y[t, w] - ϖ[t, w] for w in 1:W) + sum(p[t, :]) + ϱ[t] + s3[t] - s4[t] == sum(Lℶ["MAX"][l] * Z[t, l] - ζ[t, l] for l in 1:L))
            JuMP.@objective(ø, Min, sum(s3) + sum(s4))
            JuMP.optimize!(ø)
            @assert JuMP.termination_status(ø) == JuMP.OPTIMAL "in f(2), the Relaxed problem is still non-optimal!"
            pushcℶ(cfeasℶ, JuMP.dual.(ℵu), JuMP.dual.(ℵv), JuMP.dual.(ℵx), JuMP.objective_value(ø), uu, vv, xx)
            return 0., false
        end
        error("in f(2), status = $status")
    end
end

if true # ------------------INITIALIZATION -- BEGIN--------------------------
    o, u, v, x, lb, _ = master(cuhℶ, true) # to get an initial 1st stage decision (u, v, x)
    # # # cbh2ℶ <-- chb2ℶ <-- cf2ℶ
    # 1️⃣ initialize cf2ℶ
    Y, Z = rand(T, W), rand(T, L)
    _, ret = f(u, v, x, Y, Z)
    ret == false && error("initialization fails, change a random seed!")
    pushcℶ(cf2ℶ, ret...)
    Y, Z = rand(T, W), rand(T, L)
    _, ret = f(u, v, x, Y, Z)
    ret == false && error("initialization fails, change a random seed!")
    pushcℶ(cf2ℶ, ret...)
    # 2️⃣ initialize chb2ℶ
    Y, Z = rand(T, W), rand(T, L)
    _, ret = RC2Z(u, v, x, Y, MZ, true)
    pushcℶY(chb2ℶ, ret...)
    Y, Z = rand(T, W), rand(T, L)
    _, ret = RC2Z(u, v, x, Y, MZ, true)
    pushcℶY(chb2ℶ, ret...)
    # 3️⃣ initialize cbh2ℶ
    _, ret = RC2Y(u, v, x, MY, true)
    pushcℶ(cbh2ℶ, ret...)
    # 4️⃣ initialize cuhℶ
    o, u, v, x, lb, _ = master(cbh2ℶ, false)
    _, (etaY, Yt) = RC2Y(u, v, x, MY, false)
    puu, pvu, pxu, cnu = JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], [0.]
    continue_flag = falses(1) # allocate
    for (j, q_j) in enumerate(etaY)
        Y = Yt[j, :, :]
        _, (etaZ, Zt) = RC2Z(u, v, x, Y, MZ, false)
        for (i, p_i) in enumerate(etaZ)
            ℙ = q_j * p_i
            Z = Zt[i, :, :]
            _, ret = f(u, v, x, Y, Z)
            if ret == false
                continue_flag[1] = true
                break
            end
            pu, pv, px, pY, pZ, cn, _, _, _, _, _ = ret
            [push!(puu, ℙ * pu), push!(pvu, ℙ * pv), push!(pxu, ℙ * px)]
            cnu[1] += ℙ * (cn + ip(pY, Y) + ip(pZ, Z))
        end
        continue_flag[1] && break
    end
    if continue_flag[1]
        error("initialization fails")
    else
        pushcℶ(cuhℶ, sum(puu), sum(pvu), sum(pxu), cnu[1], u, v, x)
    end
end
# ------------------INITIALIZATION -- END----------------------------
for ı in 1:10000 # Phase 1: use the trial point gened by lb surrogate
    stagnant_flag = trues(1)
    o_cuhℶ, u, v, x, lb, COST1 = master(cuhℶ, false) # 1st stage trial decision generation
    o_cbh2ℶ = get_o(cbh2ℶ, u, v, x)
    o_chb2ℶ, (etaY, Yt) = RC2Y(u, v, x, MY, false) # trial Q generation
    puu, pvu, pxu, cnu = JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], [0.]
    continue_flag = falses(1)
    fake_ub = [COST1]
    for (j, q_j) in enumerate(etaY) # for every outcome of Y ~ Q
        Y = Yt[j, :, :]
        o_cf2ℶ, (etaZ, Zt) = RC2Z(u, v, x, Y, MZ, false) # trial P generation
        for (i, p_i) in enumerate(etaZ) # for every outcome of Z ~ P
            ℙ, Z = q_j * p_i, Zt[i, :, :]
            COST2, ret = f(u, v, x, Y, Z)
            if ret == false
                continue_flag[1] = true
                break
            end
            pushcℶ(cf2ℶ, ret...) # 1️⃣
            pu, pv, px, pY, pZ, cn, _, _, _, _, _ = ret
            [push!(puu, ℙ * pu), push!(pvu, ℙ * pv), push!(pxu, ℙ * px)]
            cnu[1] += ℙ * (cn + ip(pY, Y) + ip(pZ, Z))
            fake_ub[1] += ℙ * COST2
        end
        continue_flag[1] && break
        new_o_cf2ℶ, ret = RC2Z(u, v, x, Y, MZ, true)
        if new_o_cf2ℶ > o_cf2ℶ + .0001
            stagnant_flag[1] = false
        end
        pushcℶY(chb2ℶ, ret...) # 2️⃣
    end
    if continue_flag[1]
        continue
    else
        lb = round(lb; digits = 3)
        fakeub = round(fake_ub[1]; digits = 3)
        @info "▶ ite = $ı, lb(SP_LB) = $lb vs $fakeub = lb(MSDRO_UB)"
        new_o_chb2ℶ, ret = RC2Y(u, v, x, MY, true)
        if new_o_chb2ℶ > o_chb2ℶ + .0001
            stagnant_flag[1] = false
        end
        pu, pv, px, cn, _, _, _ = ret
        if cn + ip(pu, u) + ip(pv, v) + ip(px, x) > o_cbh2ℶ + .0001
            stagnant_flag[1] = false
        end
        pushcℶ(cbh2ℶ, ret...) # 3️⃣
        pu, pv, px, cn = sum(puu), sum(pvu), sum(pxu), cnu[1]
        if cn + ip(pu, u) + ip(pv, v) + ip(px, x) > o_cuhℶ + .0001
            stagnant_flag[1] = false
        end
        if stagnant_flag[1]
            @info "stop the main loop due to stagnation, the best lb = $lb"
            break
        end
        pushcℶ(cuhℶ, pu, pv, px, cn, u, v, x) # 4️⃣
    end
end
