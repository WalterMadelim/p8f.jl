# import PowerModels # to parse Matpower *.m data files
import LinearAlgebra
import Distributions
import Random
import Gurobi
import JuMP
using Logging

# add cut to a convex function only if the current trial point violates the cut to be addd
# trial point is generated by lb
PTH = 1e-4
Random.seed!(23)
global_logger(ConsoleLogger(Info))
GRB_ENV = Gurobi.Env()
function ip(x, y) return LinearAlgebra.dot(x, y) end
function JumpModel(i)
    if i == 0 # the most frequently used
        m = JuMP.Model(() -> Gurobi.Optimizer(GRB_ENV))
    elseif i == 1 # generic convex conic program
        m = JuMP.Model(MosekTools.Optimizer)
    elseif i == 2 # if you need Gurobi callback
        m = JuMP.direct_model(Gurobi.Optimizer(GRB_ENV))
    end
    JuMP.set_silent(m) # use JuMP.unset_silent(m) to debug when it is needed
    return m
end
function load_data()
    # network_data = PowerModels.parse_file("data/case6ww.m")
    # basic_net_data = PowerModels.make_basic_network(network_data)
    # F = PowerModels.calc_basic_ptdf_matrix(basic_net_data)
    S_BASE = 100 # MVA
    F = [0.0 -0.44078818231301325 -0.3777905547603966 -0.2799660317280192 -0.29542103345397086 -0.3797533556433226; 0.0 -0.32937180203296385 -0.3066763814017814 -0.5368505424397501 -0.27700207451336545 -0.30738349678665927; 0.0 -0.229840015654023 -0.3155330638378219 -0.18318342583223077 -0.42757689203266364 -0.31286314757001815; 0.0 0.06057464187751593 -0.354492865935812 0.018549141862024054 -0.10590781852459258 -0.20249230420747694; 0.0 0.3216443011699881 0.23423126113776493 -0.3527138586915366 0.11993854023522055 0.23695476674932447; 0.0 0.10902536164428178 -0.020830957469362865 0.03338570129374399 -0.19061834882900958 -0.016785057525005476; 0.0 0.0679675129952012 -0.23669799249298656 0.02081298380774932 -0.11883340633558914 -0.39743076066016436; 0.0 0.06529291323070335 0.270224001096538 0.019993968970548615 -0.11415717519819152 0.1491923753527435; 0.0 -0.004718271353187364 0.3752831329676507 -0.001444827108524449 0.00824935667359894 -0.35168467956022; 0.0 -0.007727500862975828 -0.07244512026401648 0.11043559886871346 -0.15706353427814482 -0.0704287300373348; 0.0 -0.06324924164201379 -0.13858514047466358 -0.019368156699224842 0.11058404966199031 -0.2508845597796152]
    B‚Ñ∂ = Dict(
        "f" =>  Int[1,1,1,2,2,2,2,3,3,4,5],
        "t" =>  Int[2,4,5,3,4,5,6,5,6,5,6],
        "BC" => [4,6,4,4,6,3,9,7,8,2,4]/10
    ) # lines
    W‚Ñ∂ = Dict(
        "id" => Int[1, 2],
        "n" => Int[2, 3],
        "CW" => [500., 400],
        "MAX" => [1.8, 1.7]
    ) # wind
    L‚Ñ∂ = Dict(
        "id" => Int[1,2,3],
        "n" => Int[4,5,6],
        "CL" => 1.8 * [3000., 2583, 2708],
        "MAX" => [1, 1.2, 1]
    ) # load
    G‚Ñ∂ = Dict(
        "id" => Int[1, 2, 3], # the 1st one is slack generator
        "n" => Int[1, 2, 3], # the 1st generator resides at bus 1
        "ZS" => [1., 0, 0], # the 1st generator is always on
        "ZP" => [0.5, 0, 0], # Pzero, consistent with IS
        "C2" => [53.3, 88.9, 74.1],
        "C1" => [1166.9, 1033.3, 1083.3],
        "C0" => [0., 200, 240], # the 1st generator has no generation cost if output power = 0
        "CR" => [83., 74, 77],
        "CST" => [210., 200, 240],
        "CSH" => [210., 200, 240],
        "PI" => [0., 0.375, 0.45], # the 1st generator doesn't have a positive output lower bound
        "PS" => [2, 1.5, 1.8],
        "RU" => [.6, .6, .6],
        "SU" => [.6, .6, .6],
        "RD" => [.6, .6, .6],
        "SD" => [.6, .6, .6],
        "UT" => Int[3, 3, 3],
        "DT" => Int[3, 3, 3]
    )
    G = length(G‚Ñ∂["n"])
    W = length(W‚Ñ∂["n"])
    L = length(L‚Ñ∂["n"])
    B, N = size(F)
    SRD = 1.5 # system reserve demand
    return B, G, W, L, F, SRD, B‚Ñ∂, G‚Ñ∂, W‚Ñ∂, L‚Ñ∂
end

B, G, W, L, F, SRD, B‚Ñ∂, G‚Ñ∂, W‚Ñ∂, L‚Ñ∂ = load_data()
MY = [0.654662 0.641636; 0.656534 0.819678; 0.511227 0.392445; 0.435808 0.123746; 0.100096 0.35382; 0.782138 0.542857; 0.798238 0.76052; 0.39923 0.309604]
MZ = [[0.7310,0.4814,0.6908,0.4326,0.1753,0.8567,0.8665,0.6107] [0.7010,0.5814,0.3908,0.1326,0.4153,0.7567,0.8565,0.5107] [0.2010,0.6814,0.1908,0.4326,0.8153,0.7567,0.6565,0.7107]]
T = 8

if true # cutDict pertinent
    function genc‚Ñ∂()
        return Dict(
            "pu" => JuMP.Containers.DenseAxisArray[],
            "pv" => JuMP.Containers.DenseAxisArray[],
            "px" => JuMP.Containers.DenseAxisArray[],
            "cn" => Float64[],
            "u" => JuMP.Containers.DenseAxisArray[],
            "v" => JuMP.Containers.DenseAxisArray[],
            "x" => JuMP.Containers.DenseAxisArray[],
        )
    end
    function genc‚Ñ∂Y()
        return Dict(
            "pY" => Matrix[], # i.e. ak
            "Y" => Matrix[] # üîß the r.v.
        )
    end
    function genc‚Ñ∂Z()
        return Dict(
            "pZ" => Matrix[], # i.e. ak
            "Z" => Matrix[] # üîß the r.v.
        )
    end
    function lengthc‚Ñ∂(c‚Ñ∂) return length(c‚Ñ∂["cn"]) end
    cf2‚Ñ∂ = merge(genc‚Ñ∂(), genc‚Ñ∂Y(), genc‚Ñ∂Z()) # "Z" üîß the r.v.
    cf1‚Ñ∂ = merge(genc‚Ñ∂(), genc‚Ñ∂Z(), genc‚Ñ∂Y()) # "Y" üîß the r.v.
    chb2‚Ñ∂ = merge(genc‚Ñ∂(), genc‚Ñ∂Y()) # "Y" üîß the r.v.
    chb1‚Ñ∂ = merge(genc‚Ñ∂(), genc‚Ñ∂Z()) # "Z" üîß the r.v.
    cbh2‚Ñ∂, cbh1‚Ñ∂, cuh‚Ñ∂, cfeas‚Ñ∂ = genc‚Ñ∂(), genc‚Ñ∂(), genc‚Ñ∂(), genc‚Ñ∂()
    function pushc‚Ñ∂(c‚Ñ∂, pu, pv, px, cn, u, v, x) # for `cuh‚Ñ∂`, `cbh2‚Ñ∂`, `cbh1‚Ñ∂`, `cfeas‚Ñ∂`
        push!(c‚Ñ∂["pu"], pu)
        push!(c‚Ñ∂["pv"], pv)
        push!(c‚Ñ∂["px"], px)
        push!(c‚Ñ∂["cn"], cn)
        push!(c‚Ñ∂["u"], u)
        push!(c‚Ñ∂["v"], v)
        push!(c‚Ñ∂["x"], x)
    end
    function pushc‚Ñ∂(c‚Ñ∂, pu, pv, px, pY, pZ, cn, u, v, x, Y, Z) # for `cf1‚Ñ∂` and `cf1‚Ñ∂`
        push!(c‚Ñ∂["pY"], pY)
        push!(c‚Ñ∂["Y"], Y)
        push!(c‚Ñ∂["pZ"], pZ)
        push!(c‚Ñ∂["Z"], Z)
        pushc‚Ñ∂(c‚Ñ∂, pu, pv, px, cn, u, v, x)
    end
    function pushc‚Ñ∂Y(c‚Ñ∂, pu, pv, px, pY, cn, u, v, x, Y)
        push!(c‚Ñ∂["pY"], pY)
        push!(c‚Ñ∂["Y"], Y)
        pushc‚Ñ∂(c‚Ñ∂, pu, pv, px, cn, u, v, x)
    end
end
function master(c‚Ñ∂, set_lb)
    √∏ = JumpModel(0)
    JuMP.@variable(√∏, u[1:T, 2:G], Bin)
    JuMP.@variable(√∏, v[1:T, 2:G], Bin)
    JuMP.@variable(√∏, x[0:T, 2:G], Bin)
    JuMP.@expression(√∏, CGst[t = 1:T, g = 2:G], G‚Ñ∂["CST"][g] * u[t, g])
    JuMP.@expression(√∏, CGsh[t = 1:T, g = 2:G], G‚Ñ∂["CSH"][g] * v[t, g])
    JuMP.@expression(√∏, COST1, sum(CGst) + sum(CGsh))
    JuMP.@constraint(√∏, [t = 1:T, g = 2:G], x[t, g] - x[t-1, g] == u[t, g] - v[t, g]) # linking constr, but authentic 1st stage
    [   JuMP.fix(x[0, g], G‚Ñ∂["ZS"][g]; force = true) for g in 2:G   ]
    JuMP.@constraint(√∏, [g = 2:G, t = 1:T-G‚Ñ∂["UT"][g]+1], sum(x[i, g] for i in t:t+G‚Ñ∂["UT"][g]-1) >= G‚Ñ∂["UT"][g] * u[t, g])
    JuMP.@constraint(√∏, [g = 2:G, t = T-G‚Ñ∂["UT"][g]+1:T], sum(x[i, g] - u[t, g] for i in t:T) >= 0.)
    JuMP.@constraint(√∏, [g = 2:G, t = 1:T-G‚Ñ∂["DT"][g]+1], sum(1. - x[i, g] for i in t:t+G‚Ñ∂["DT"][g]-1) >= G‚Ñ∂["DT"][g] * v[t, g])
    JuMP.@constraint(√∏, [g = 2:G, t = T-G‚Ñ∂["DT"][g]+1:T], sum(1. - x[i, g] - v[t, g] for i in t:T) >= 0.)
    ‚Ñ∂ = cfeas‚Ñ∂
    for (pu, pv, px, cn, ut, vt, xt) in zip(‚Ñ∂["pu"], ‚Ñ∂["pv"], ‚Ñ∂["px"], ‚Ñ∂["cn"], ‚Ñ∂["u"], ‚Ñ∂["v"], ‚Ñ∂["x"])
        JuMP.@constraint(√∏, 0. >= cn + ip(pu, u .- ut) + ip(pv, v .- vt) + ip(px, x .- xt)) # üëç Benders' Feas. cut
    end
    JuMP.@variable(√∏, o) # the trial value to be cut off at the next iteration
    for (pu, pv, px, cn) in zip(c‚Ñ∂["pu"], c‚Ñ∂["pv"], c‚Ñ∂["px"], c‚Ñ∂["cn"])
        JuMP.@constraint(√∏, o >= cn + ip(pu, u) + ip(pv, v) + ip(px, x)) # üëç sup's cut
    end
    JuMP.@variable(√∏, objterm)
    set_lb && JuMP.set_lower_bound(objterm, -3.)
    JuMP.@constraint(√∏, objterm >= COST1 + o)
    JuMP.@objective(√∏, Min, objterm)
    JuMP.optimize!(√∏)
    status = JuMP.termination_status(√∏)
    @assert status == JuMP.OPTIMAL "in master(), status = $status"
    return JuMP.value(o), JuMP.value.(u), JuMP.value.(v), JuMP.value.(x), JuMP.value(objterm), JuMP.value(COST1)
end
function get_o(c‚Ñ∂, u, v, x) # for cbh2‚Ñ∂ or cbh1‚Ñ∂
    √∏ = JumpModel(0)
    JuMP.@variable(√∏, o)
    for (pu, pv, px, cn) in zip(c‚Ñ∂["pu"], c‚Ñ∂["pv"], c‚Ñ∂["px"], c‚Ñ∂["cn"])
        JuMP.@constraint(√∏, o >= cn + ip(pu, u) + ip(pv, v) + ip(px, x))
    end
    JuMP.@objective(√∏, Min, o)
    JuMP.optimize!(√∏)
    status = JuMP.termination_status(√∏)
    @assert status == JuMP.OPTIMAL "in get_o(), status = $status"
    return JuMP.value(o)
end
function RC2Y(u, v, x, MY, isbwd) # utilize `chb2‚Ñ∂` & generate trial Y ~ Q & preparing cut for `cbh2‚Ñ∂`
    c‚Ñ∂ = chb2‚Ñ∂ # \ref{chb2‚Ñ∂}
    K = lengthc‚Ñ∂(c‚Ñ∂)
    function a(k) return c‚Ñ∂["pY"][k] end
    function b(k, u, v, x) return ip(c‚Ñ∂["pu"][k], u) + ip(c‚Ñ∂["pv"][k], v) + ip(c‚Ñ∂["px"][k], x) + c‚Ñ∂["cn"][k] end
    √∏ = JumpModel(0)
    JuMP.@variable(√∏, Œ±)
    JuMP.@variable(√∏, Œ≤[1:T, 1:W])
    JuMP.@objective(√∏, Min, Œ± + ip(MY, Œ≤))
    JuMP.@variable(√∏, œÇ[1:K, 1:T, 1:W] >= 0.)
    JuMP.@constraint(√∏, Œ∑[k = 1:K], Œ± >= b(k, u, v, x) + sum(œÇ[k, :, :]))
    JuMP.@constraint(√∏, Œæ[k = 1:K, t = 1:T, w = 1:W], Œ≤[t, w] + œÇ[k, t, w] >= a(k)[t, w])
    JuMP.optimize!(√∏)
    status = JuMP.termination_status(√∏)
    @assert status == JuMP.OPTIMAL "in RC2Y, status = $status"
    Œ∑, Œæ = JuMP.dual.(Œ∑)::Vector, JuMP.dual.(Œæ)::Array
    if isbwd # (sup's) cut preparation o >= cn + <pu, u> + <pv, v> + <px, x>
        pu = sum(Œ∑[k] .* c‚Ñ∂["pu"][k] for k in 1:K)
        pv = sum(Œ∑[k] .* c‚Ñ∂["pv"][k] for k in 1:K)
        px = sum(Œ∑[k] .* c‚Ñ∂["px"][k] for k in 1:K)
        cn = sum(Œ∑[k]  * c‚Ñ∂["cn"][k] + ip(Œæ[k, :, :], a(k)) for k in 1:K)
        return JuMP.objective_value(√∏), (pu, pv, px, cn, u, v, x) # \label{cbh2‚Ñ∂}
    else # generate trial Y ~ Q
        bitvec = Œ∑ .> PTH # eliminate 0's
        Œ∑, Œæ = Œ∑[bitvec], Œæ[bitvec, :, :]
        Ytrial = [Œæ[i, r, c] / Œ∑[i] for i in eachindex(Œ∑), r in 1:size(Œæ)[2], c in 1:size(Œæ)[3]]
        return JuMP.objective_value(√∏), (Œ∑, Ytrial)
    end
end
function RC2Z(u, v, x, Y, MZ, isbwd) # utilize `cf2‚Ñ∂` & generate trial Z ~ P & preparing cut for `chb2‚Ñ∂`
    c‚Ñ∂ = cf2‚Ñ∂ 
    K = lengthc‚Ñ∂(c‚Ñ∂)
    function a(k) return c‚Ñ∂["pZ"][k] end
    function b(k, u, v, x, Y) return ip(c‚Ñ∂["pu"][k], u) + ip(c‚Ñ∂["pv"][k], v) + ip(c‚Ñ∂["px"][k], x) + ip(c‚Ñ∂["pY"][k], Y) + c‚Ñ∂["cn"][k] end
    √∏ = JumpModel(0)
    JuMP.@variable(√∏, Œ±)
    JuMP.@variable(√∏, Œ≤[1:T, 1:L])
    JuMP.@objective(√∏, Min, Œ± + ip(MZ, Œ≤))
    JuMP.@variable(√∏, œÇ[1:K, 1:T, 1:L] >= 0.)
    JuMP.@constraint(√∏, Œ∑[k = 1:K], Œ± >= b(k, u, v, x, Y) + sum(œÇ[k, :, :]))
    JuMP.@constraint(√∏, Œæ[k = 1:K, t = 1:T, l = 1:L], Œ≤[t, l] + œÇ[k, t, l] >= a(k)[t, l])
    JuMP.optimize!(√∏)
    status = JuMP.termination_status(√∏)
    @assert status == JuMP.OPTIMAL "in RC2Z, status = $status"
    Œ∑, Œæ = JuMP.dual.(Œ∑)::Vector, JuMP.dual.(Œæ)::Array
    if isbwd # (sup's) cut preparation o >= cn + <pu, u> + <pv, v> + <px, x> + <pY, Y>
        pu = sum(Œ∑[k] .* c‚Ñ∂["pu"][k] for k in 1:K)
        pv = sum(Œ∑[k] .* c‚Ñ∂["pv"][k] for k in 1:K)
        px = sum(Œ∑[k] .* c‚Ñ∂["px"][k] for k in 1:K)
        pY = sum(Œ∑[k] .* c‚Ñ∂["pY"][k] for k in 1:K)
        cn = sum(Œ∑[k]  * c‚Ñ∂["cn"][k] + ip(Œæ[k, :, :], a(k)) for k in 1:K)
        return JuMP.objective_value(√∏), (pu, pv, px, pY, cn, u, v, x, Y) # \label{chb2‚Ñ∂}
    else # generate trial Z ~ P
        bitvec = Œ∑ .> PTH # eliminate 0's
        Œ∑, Œæ = Œ∑[bitvec], Œæ[bitvec, :, :]
        Ztrial = [Œæ[i, r, c] / Œ∑[i] for i in eachindex(Œ∑), r in 1:size(Œæ)[2], c in 1:size(Œæ)[3]]
        return JuMP.objective_value(√∏), (Œ∑, Ztrial)
    end
end
function f(uu, vv, xx, YY, ZZ) # preparing cut derived from Benders' cut
    function Œ∏(g, p) return G‚Ñ∂["C2"][g] * p^2 + G‚Ñ∂["C1"][g] * p + G‚Ñ∂["C0"][g] end
    √∏ = JumpModel(0)
    JuMP.@variable(√∏, u[1:T, 2:G])
    JuMP.@variable(√∏, v[1:T, 2:G])
    JuMP.@variable(√∏, x[0:T, 2:G])
    JuMP.@variable(√∏, Y[1:T, 1:W])
    JuMP.@variable(√∏, Z[1:T, 1:L])
    JuMP.@constraint(√∏, ‚Ñµu[t = 1:T, g = 2:G], u[t, g] == uu[t, g])
    JuMP.@constraint(√∏, ‚Ñµv[t = 1:T, g = 2:G], v[t, g] == vv[t, g])
    JuMP.@constraint(√∏, ‚Ñµx[t = 0:T, g = 2:G], x[t, g] == xx[t, g])
    JuMP.@constraint(√∏, ‚ÑµY[t = 1:T, w = 1:W], Y[t, w] == YY[t, w])
    JuMP.@constraint(√∏, ‚ÑµZ[t = 1:T, l = 1:L], Z[t, l] == ZZ[t, l])
    JuMP.@variable(√∏, œñ[1:T, 1:W] >= 0.)
    JuMP.@variable(√∏, Œ∂[1:T, 1:L] >= 0.)
    JuMP.@expression(√∏, CW[t = 1:T, w = 1:W], W‚Ñ∂["CW"][w] * œñ[t, w])
    JuMP.@expression(√∏, CL[t = 1:T, l = 1:L], L‚Ñ∂["CL"][l] * Œ∂[t, l])
    JuMP.@constraint(√∏, ‚Ñµœñ[t = 1:T, w in 1:W], œñ[t, w] - W‚Ñ∂["MAX"][w] * Y[t, w] <= 0.)
    JuMP.@constraint(√∏, ‚ÑµŒ∂[t = 1:T, l in 1:L], Œ∂[t, l] - L‚Ñ∂["MAX"][l] * Z[t, l] <= 0.)
    JuMP.@variable(√∏, œÅ[1:T, 1:G] >= 0.)
    JuMP.@expression(√∏, CGres[t = 1:T, g = 1:G], G‚Ñ∂["CR"][g] * œÅ[t, g])
    JuMP.@variable(√∏, œ±[1:T] >= 0.)
    JuMP.@variable(√∏, œ±sq[1:T])
    JuMP.@constraint(√∏, [t = 1:T], [œ±sq[t] + 1, œ±sq[t] - 1, 2 * œ±[t]] in JuMP.SecondOrderCone()) # üçß
    JuMP.@expression(√∏, CGgen1[t = 1:T], G‚Ñ∂["C2"][1] * œ±sq[t] + G‚Ñ∂["C1"][1] * œ±[t])
    JuMP.@variable(√∏, p[0:T, 2:G]) # power output of the Generator 2:G
    [ JuMP.fix(p[0, g], G‚Ñ∂["ZP"][g]; force = true) for g in 2:G ]
    JuMP.@variable(√∏, psq[1:T, 2:G])
    JuMP.@constraint(√∏, [t = 1:T, g = 2:G], [psq[t, g] + 1, psq[t, g] - 1, 2 * p[t, g]] in JuMP.SecondOrderCone()) # üçß
    JuMP.@expression(√∏, CGgen2[t = 1:T, g = 2:G], G‚Ñ∂["C2"][g] * psq[t, g] + G‚Ñ∂["C1"][g] * p[t, g] + G‚Ñ∂["C0"][g])
    JuMP.@variable(√∏, œï[1:T, 2:G] >= 0.) # epi-variable of Cost_Generators, only for 2:G
    JuMP.@constraint(√∏, ‚Ñµœï[t = 1:T, g = 2:G], CGgen2[t, g] - (1. - x[t, g]) * Œ∏(g, G‚Ñ∂["PS"][g]) - œï[t, g] <= 0.)
    JuMP.@constraint(√∏, ‚Ñµdpl[t = 1:T, g = 2:G], -G‚Ñ∂["RD"][g] * x[t, g] - G‚Ñ∂["SD"][g] * v[t, g] + p[t-1, g] - p[t, g] <= 0.)
    JuMP.@constraint(√∏, ‚Ñµdpr[t = 1:T, g = 2:G], p[t, g] - p[t-1, g] - G‚Ñ∂["RU"][g] * x[t-1, g] - G‚Ñ∂["SU"][g] * u[t, g] <= 0.)
    JuMP.@constraint(√∏, ‚ÑµSRD[t = 1:T], SRD - sum(œÅ[t, :]) <= 0.)
    JuMP.@constraint(√∏, ‚Ñµœ±[t = 1:T], œ±[t] + œÅ[t, 1] - G‚Ñ∂["PS"][1] <= 0.)
    JuMP.@constraint(√∏, ‚ÑµPI[t = 1:T, g = 2:G], G‚Ñ∂["PI"][g] * x[t, g] - p[t, g] <= 0.)
    JuMP.@constraint(√∏, ‚ÑµPS[t = 1:T, g = 2:G], p[t, g] + œÅ[t, g] - G‚Ñ∂["PS"][g] * x[t, g] <= 0.)
    JuMP.@expression(√∏, line_flow[t = 1:T, b = 1:B], sum(F[b, W‚Ñ∂["n"][w]] * (W‚Ñ∂["MAX"][w] * Y[t, w] - œñ[t, w]) for w in 1:W) + 
                                                sum(F[b, G‚Ñ∂["n"][g]] * p[t, g] for g in 2:G)
                                                - sum(F[b, L‚Ñ∂["n"][l]] * (L‚Ñ∂["MAX"][l] * Z[t, l] - Œ∂[t, l]) for l in 1:L))
    JuMP.@constraint(√∏, ‚Ñµlfl[t = 1:T, b = 1:B], -B‚Ñ∂["BC"][b] <= line_flow[t, b])
    JuMP.@constraint(√∏, ‚Ñµlfr[t = 1:T, b = 1:B], line_flow[t, b] <= B‚Ñ∂["BC"][b])
    JuMP.@constraint(√∏, ‚Ñµbalance[t = 1:T], sum(W‚Ñ∂["MAX"][w] * Y[t, w] - œñ[t, w] for w in 1:W) + sum(p[t, :]) + œ±[t] == sum(L‚Ñ∂["MAX"][l] * Z[t, l] - Œ∂[t, l] for l in 1:L))
    JuMP.@objective(√∏, Min, sum(CW) + sum(CL) + sum(CGres) + sum(CGgen1) + sum(œï))
    JuMP.set_attribute(√∏, "QCPDual", 1)
    JuMP.optimize!(√∏)
    status = JuMP.termination_status(√∏)
    if status == JuMP.OPTIMAL
        objVal = JuMP.objective_value(√∏)
        pu, pv, px, pY, pZ = JuMP.dual.(‚Ñµu), JuMP.dual.(‚Ñµv), JuMP.dual.(‚Ñµx), JuMP.dual.(‚ÑµY), JuMP.dual.(‚ÑµZ)
        cn = objVal - (ip(pu, uu) + ip(pv, vv) + ip(px, xx) + ip(pY, YY) + ip(pZ, ZZ))
        return objVal, (pu, pv, px, pY, pZ, cn, uu, vv, xx, YY, ZZ) # optimality cut
    else
        if status == JuMP.INFEASIBLE_OR_UNBOUNDED
            JuMP.set_attribute(√∏, "DualReductions", 0)
            JuMP.optimize!(√∏)
            status = JuMP.termination_status(√∏)
            @assert status == JuMP.INFEASIBLE "in f(1), status = $status"
        end
        if status == JuMP.INFEASIBLE
            [JuMP.delete.(√∏, ‚Ñµbalance), JuMP.unregister(√∏, :‚Ñµbalance)]
            JuMP.@variable(√∏, s3[t = 1:T] >= 0.)
            JuMP.@variable(√∏, s4[t = 1:T] >= 0.)
            JuMP.@constraint(√∏, [t = 1:T], sum(W‚Ñ∂["MAX"][w] * Y[t, w] - œñ[t, w] for w in 1:W) + sum(p[t, :]) + œ±[t] + s3[t] - s4[t] == sum(L‚Ñ∂["MAX"][l] * Z[t, l] - Œ∂[t, l] for l in 1:L))
            JuMP.@objective(√∏, Min, sum(s3) + sum(s4))
            JuMP.optimize!(√∏)
            @assert JuMP.termination_status(√∏) == JuMP.OPTIMAL "in f(2), the Relaxed problem is still non-optimal!"
            pushc‚Ñ∂(cfeas‚Ñ∂, JuMP.dual.(‚Ñµu), JuMP.dual.(‚Ñµv), JuMP.dual.(‚Ñµx), JuMP.objective_value(√∏), uu, vv, xx)
            return 0., false
        end
        error("in f(2), status = $status")
    end
end

if true # ------------------INITIALIZATION -- BEGIN--------------------------
    o, u, v, x, lb, _ = master(cuh‚Ñ∂, true) # to get an initial 1st stage decision (u, v, x)
    # # # cbh2‚Ñ∂ <-- chb2‚Ñ∂ <-- cf2‚Ñ∂
    # 1Ô∏è‚É£ initialize cf2‚Ñ∂
    Y, Z = rand(T, W), rand(T, L)
    _, ret = f(u, v, x, Y, Z)
    ret == false && error("initialization fails, change a random seed!")
    pushc‚Ñ∂(cf2‚Ñ∂, ret...)
    Y, Z = rand(T, W), rand(T, L)
    _, ret = f(u, v, x, Y, Z)
    ret == false && error("initialization fails, change a random seed!")
    pushc‚Ñ∂(cf2‚Ñ∂, ret...)
    # 2Ô∏è‚É£ initialize chb2‚Ñ∂
    Y, Z = rand(T, W), rand(T, L)
    _, ret = RC2Z(u, v, x, Y, MZ, true)
    pushc‚Ñ∂Y(chb2‚Ñ∂, ret...)
    Y, Z = rand(T, W), rand(T, L)
    _, ret = RC2Z(u, v, x, Y, MZ, true)
    pushc‚Ñ∂Y(chb2‚Ñ∂, ret...)
    # 3Ô∏è‚É£ initialize cbh2‚Ñ∂
    _, ret = RC2Y(u, v, x, MY, true)
    pushc‚Ñ∂(cbh2‚Ñ∂, ret...)
    # 4Ô∏è‚É£ initialize cuh‚Ñ∂
    o, u, v, x, lb, _ = master(cbh2‚Ñ∂, false)
    _, (etaY, Yt) = RC2Y(u, v, x, MY, false)
    puu, pvu, pxu, cnu = JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], [0.]
    continue_flag = falses(1) # allocate
    for (j, q_j) in enumerate(etaY)
        Y = Yt[j, :, :]
        _, (etaZ, Zt) = RC2Z(u, v, x, Y, MZ, false)
        for (i, p_i) in enumerate(etaZ)
            ‚Ñô = q_j * p_i
            Z = Zt[i, :, :]
            _, ret = f(u, v, x, Y, Z)
            if ret == false
                continue_flag[1] = true
                break
            end
            pu, pv, px, pY, pZ, cn, _, _, _, _, _ = ret
            [push!(puu, ‚Ñô * pu), push!(pvu, ‚Ñô * pv), push!(pxu, ‚Ñô * px)]
            cnu[1] += ‚Ñô * (cn + ip(pY, Y) + ip(pZ, Z))
        end
        continue_flag[1] && break
    end
    if continue_flag[1]
        error("initialization fails")
    else
        pushc‚Ñ∂(cuh‚Ñ∂, sum(puu), sum(pvu), sum(pxu), cnu[1], u, v, x)
    end
end
# ------------------INITIALIZATION -- END----------------------------
for ƒ± in 1:10000 # Phase 1: use the trial point gened by lb surrogate
    stagnant_flag = trues(1)
    o_cuh‚Ñ∂, u, v, x, lb, COST1 = master(cuh‚Ñ∂, false) # 1st stage trial decision generation
    o_cbh2‚Ñ∂ = get_o(cbh2‚Ñ∂, u, v, x)
    o_chb2‚Ñ∂, (etaY, Yt) = RC2Y(u, v, x, MY, false) # trial Q generation
    puu, pvu, pxu, cnu = JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], JuMP.Containers.DenseAxisArray[], [0.]
    continue_flag = falses(1)
    fake_ub = [COST1]
    for (j, q_j) in enumerate(etaY) # for every outcome of Y ~ Q
        Y = Yt[j, :, :]
        o_cf2‚Ñ∂, (etaZ, Zt) = RC2Z(u, v, x, Y, MZ, false) # trial P generation
        for (i, p_i) in enumerate(etaZ) # for every outcome of Z ~ P
            ‚Ñô, Z = q_j * p_i, Zt[i, :, :]
            COST2, ret = f(u, v, x, Y, Z)
            if ret == false
                continue_flag[1] = true
                break
            end
            pushc‚Ñ∂(cf2‚Ñ∂, ret...) # 1Ô∏è‚É£
            pu, pv, px, pY, pZ, cn, _, _, _, _, _ = ret
            [push!(puu, ‚Ñô * pu), push!(pvu, ‚Ñô * pv), push!(pxu, ‚Ñô * px)]
            cnu[1] += ‚Ñô * (cn + ip(pY, Y) + ip(pZ, Z))
            fake_ub[1] += ‚Ñô * COST2
        end
        continue_flag[1] && break
        new_o_cf2‚Ñ∂, ret = RC2Z(u, v, x, Y, MZ, true)
        if new_o_cf2‚Ñ∂ > o_cf2‚Ñ∂ + .0001
            stagnant_flag[1] = false
        end
        pushc‚Ñ∂Y(chb2‚Ñ∂, ret...) # 2Ô∏è‚É£
    end
    if continue_flag[1]
        continue
    else
        lb = round(lb; digits = 3)
        fakeub = round(fake_ub[1]; digits = 3)
        @info "‚ñ∂ ite = $ƒ±, lb(SP_LB) = $lb vs $fakeub = lb(MSDRO_UB)"
        new_o_chb2‚Ñ∂, ret = RC2Y(u, v, x, MY, true)
        if new_o_chb2‚Ñ∂ > o_chb2‚Ñ∂ + .0001
            stagnant_flag[1] = false
        end
        pu, pv, px, cn, _, _, _ = ret
        if cn + ip(pu, u) + ip(pv, v) + ip(px, x) > o_cbh2‚Ñ∂ + .0001
            stagnant_flag[1] = false
        end
        pushc‚Ñ∂(cbh2‚Ñ∂, ret...) # 3Ô∏è‚É£
        pu, pv, px, cn = sum(puu), sum(pvu), sum(pxu), cnu[1]
        if cn + ip(pu, u) + ip(pv, v) + ip(px, x) > o_cuh‚Ñ∂ + .0001
            stagnant_flag[1] = false
        end
        if stagnant_flag[1]
            @info "stop the main loop due to stagnation, the best lb = $lb"
            break
        end
        pushc‚Ñ∂(cuh‚Ñ∂, pu, pv, px, cn, u, v, x) # 4Ô∏è‚É£
    end
end
